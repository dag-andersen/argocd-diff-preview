{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Argo CD Diff Preview is a tool that renders the diff between two branches in a Git repository. It is designed to render manifests generated by Argo CD, providing a clear and concise view of the changes between two branches. It operates similarly to Atlantis for Terraform, creating a plan that outlines the proposed changes.</p>"},{"location":"#3-example-pull-requests","title":"3 Example Pull Requests:","text":"<ul> <li>Helm Example | Internal Chart</li> <li>Helm example | External Chart: Nginx</li> <li>Kustomize Example</li> </ul>"},{"location":"#overview_1","title":"Overview","text":"<p>The safest way to make changes to your Helm Charts and Kustomize Overlays in your GitOps repository is to let Argo CD render them for you. Since the diff is rendered by Argo CD itself, it is as accurate as possible.</p> <p>The tool supports three approaches for generating previews:</p> Approach Best For Overhead Ephemeral Cluster (Default) Getting started, complete isolation ~60-90s Pre-installed Argo CD Teams prioritizing speed &lt;10s Pre-installed Argo CD + Self-Hosted Runner Speed + security &lt;10s <p>Check out How it works</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Accurate diffs - Renders manifests using Argo CD itself, so the diff is as accurate as possible</li> <li>Complete isolation - Run with ephemeral clusters - no access to your real cluster or Argo CD instance required</li> <li>Connect to pre-installed Argo CD - Skip cluster creation for faster execution (~60-90s saved). [Docs]</li> <li>Run locally - Test changes before opening a pull request</li> <li>Private repos &amp; charts - Works with private Git repositories and Helm charts</li> <li>Multi-source applications - Full support for Argo CD multi-source apps</li> <li>ApplicationSets - Supports List, Git, Matrix, Merge, and other generators</li> <li>Config Management Plugins - Use custom CMPs via Argo CD Helm chart configuration</li> <li>External chart visibility - See exactly what changed when updating a Helm chart version (e.g., Nginx). PR example</li> <li>Smart filtering - Filter applications by file path, regex, labels, or change detection. [Docs]</li> <li>Diff noise filtering - Ignore version bumps, generated values, or other noisy changes with <code>--diff-ignore</code></li> <li>Multiple output formats - Generates Markdown (for PR comments), HTML, and full YAML manifests</li> <li>Dry run mode - Preview which applications would be rendered without creating a cluster</li> </ul>"},{"location":"#why-do-we-need-this","title":"Why do we need this?","text":"<p>In the Kubernetes world, we often use templating tools like Kustomize and Helm to generate our Kubernetes manifests. These tools make maintaining and streamlining configuration easier across applications and environments. However, they also make it harder to visualize the application's actual configuration in the cluster.</p> <p>Mentally parsing Helm templates and Kustomize patches is hard without rendering the actual output. Thus, making mistakes while modifying an application's configuration is relatively easy.</p> <p>In the field of GitOps and infrastructure as code, all configurations are checked into Git and modified through PRs. The code changes in the PR are reviewed by a human, who needs to understand the changes made to the configuration. This is hard when the configuration is generated through templating tools like Kustomize and Helm.</p>"},{"location":"#blog-posts","title":"Blog Posts","text":"<ul> <li>Rendering the TRUE Argo CD diff on your PRs</li> <li>Argo CD: Previewing Pull Request changes in SECONDS! \ud83e\udd75\u26a1\ufe0f\u23f0</li> </ul>"},{"location":"#talks","title":"Talks","text":""},{"location":"#argocon-na-2024","title":"ArgoCon NA 2024","text":"<p> <code>argocd-diff-preview</code> was presented at ArgoCon 2024 in Salt Lake City, US. The talk covered current tools and methods for visualizing code changes in GitOps workflows and introduced a new approach using ephemeral clusters to render accurate diffs directly on pull requests.</p> <ul> <li>Talk description: GitOps Safety: Rendering Accurate ArgoCD Diffs Directly on Pull Requests</li> <li>Talk recording: YouTube</li> </ul>"},{"location":"#argocon-eu-2026","title":"ArgoCon EU 2026","text":"<p><code>argocd-diff-preview</code> will be presented at ArgoCon EU 2026 in Amsterdam, The Netherlands. This talk shows how you can reduce preview times from minutes to seconds by connecting to a pre-configured Argo CD instance instead of spinning up ephemeral clusters. Includes real-world examples from Egmont and TangoMe.</p> <ul> <li>Talk description: Argo CD: Previewing Pull Request Changes in SECONDS!</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to ArgoCD Diff Preview! Whether you want to fix bugs, add new features, or improve documentation, your help is appreciated.</p> <p>Please check out our contribution guidelines for details on how to set up your development environment, run tests, and submit changes.</p>"},{"location":"application-selection/","title":"Application Selection","text":"<p>Rendering manifests for all applications in your repository on every pull request can be time-consuming, especially in large monorepos. By default, <code>argocd-diff-preview</code> renders all applications it finds, but you can significantly speed up the process by limiting which applications are rendered.</p> <p>This page describes 4 strategies for controlling which applications are rendered:</p> <ol> <li>Rendering only changed applications - Automatically detect and render only applications affected by file changes</li> <li>Ignoring individual applications - Explicitly exclude specific applications from rendering</li> <li>Label selectors - Select/filter applications based on Kubernetes labels</li> <li>File path regex - Target applications based on their file path location</li> </ol>"},{"location":"application-selection/#1-rendering-only-changed-applications","title":"1. Rendering Only Changed Applications","text":"<p>The most efficient way to optimize rendering is to process only applications that are actually affected by changes in your pull request. This approach uses annotations to define which files each application depends on, then automatically renders only the relevant applications.</p>"},{"location":"application-selection/#option-a-watch-pattern-annotation","title":"Option A: Watch Pattern Annotation","text":"<p>The <code>argocd-diff-preview/watch-pattern</code> annotation allows you to specify which file paths should trigger a render for each application. When files matching the pattern change in a pull request, the application will be rendered.</p> <p>How it works:</p> <ul> <li>Add the <code>argocd-diff-preview/watch-pattern</code> annotation to your Application or ApplicationSet manifests</li> <li>The annotation accepts a comma-separated list of file paths or regex patterns</li> <li>Applications are automatically rendered when their watch-patterns match changed files</li> <li>Applications are always rendered if their own manifest file changes (no need to include it in the pattern)</li> </ul> <p>Note</p> <p>The <code>argocd-diff-preview/watch-pattern</code> annotation must exist in the base branch for filtering to work. This ensures the tool knows which files to watch before comparing branches.</p> <p>Example: Application with Watch Pattern</p> <p>In this example, the <code>my-app</code> application will be rendered if: - Changes are made to files in <code>examples/helm/charts/myApp/</code> (matching the regex pattern <code>examples/helm/charts/myApp/.*</code>) - Changes are made to the <code>examples/helm/values/filtered.yaml</code> file - Changes are made to the Application manifest itself (automatic behavior)</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/watch-pattern: |\n      examples/helm/charts/myApp/.*,\n      examples/helm/values/filtered.yaml\nspec:\n  sources:\n    - repoURL: https://github.com/dag-andersen/argocd-diff-preview\n      ref: local-files\n    - path: examples/helm/charts/myApp\n      repoURL: https://github.com/dag-andersen/argocd-diff-preview\n      helm:\n        valueFiles:\n          - $local-files/examples/helm/values/filtered.yaml\n  # ...\n</code></pre> <p>Example: ApplicationSet with Watch Pattern</p> <p>For ApplicationSets, add the annotation in two places: - On the ApplicationSet itself (<code>metadata.annotations</code>) - On the template that generates applications (<code>spec.template.metadata.annotations</code>)</p> <p>The template annotation can use generator variables like <code>{{ .path.basename }}</code> to create application-specific watch-patterns.</p> ApplicationSet<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: my-appset\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/watch-pattern: |\n      examples/helm/charts/.*, \n      examples/helm/values/filtered.yaml\nspec:\n  generators:\n    - git:\n        repoURL: https://github.com/dag-andersen/argocd-diff-preview\n        revision: HEAD\n        directories:\n          - path: examples/helm/charts/*\n  template:\n    metadata:\n      name: '{{ .path.basename }}'\n      annotations:\n        argocd-diff-preview/watch-pattern: |\n          examples/helm/charts/{{ .path.basename }}/.*, \n          examples/helm/values/filtered.yaml\n    spec:\n      project: {{ .path.basename }}\n      source:\n        repoURL: https://github.com/dag-andersen/argocd-diff-preview\n        targetRevision: HEAD\n        path: '{{ .path.path }}'\n        helm:\n          valueFiles:\n            - ../../values/filtered.yaml\n            - values.yaml\n  # ...\n</code></pre>"},{"location":"application-selection/#option-b-argo-cd-manifest-paths-annotation-beta","title":"Option B: Argo CD Manifest Paths Annotation (BETA)","text":"<p>As an alternative to the <code>watch-pattern</code> annotation, you can use Argo CD's native <code>argocd.argoproj.io/manifest-generate-paths</code> annotation. This annotation serves a similar purpose: defining which file paths should trigger a render for the application.</p> <p>Example:</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: guestbook\n  namespace: argocd\n  annotations:\n    argocd.argoproj.io/manifest-generate-paths: .\nspec:\n  source:\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n    targetRevision: HEAD\n    path: guestbook\n  # ...\n</code></pre> <p>For more details on this annotation, see the Argo CD documentation.</p>"},{"location":"application-selection/#implementing-changed-file-detection-in-cicd","title":"Implementing Changed File Detection in CI/CD","text":"<p>Once you've added watch-pattern annotations to your applications, configure your CI/CD pipeline to detect changed files and use them for filtering. Here are two approaches:</p>"},{"location":"application-selection/#approach-1-automatic-detection-recommended","title":"Approach 1: Automatic Detection (Recommended)","text":"<p>The simplest approach is to use the <code>--auto-detect-files-changed</code> flag. The tool will automatically determine which files changed in the pull request and match them against the watch-patterns.</p> <p>Configuration options:</p> <ul> <li><code>--auto-detect-files-changed=true</code> - Enables automatic file change detection</li> <li><code>--watch-if-no-watch-pattern-found=true</code> - Renders applications that don't have a watch-pattern annotation </li> <li><code>--watch-if-no-watch-pattern-found=false</code> - Skips applications that don't have a watch-pattern annotation (default behavior)</li> </ul> <p>How it works: - Applications with a <code>watch-pattern</code> annotation are rendered only if their patterns match changed files - Applications without a <code>watch-pattern</code> annotation follow the <code>--watch-if-no-watch-pattern-found</code> setting - Applications are always rendered if their own manifest file changes</p> .github/workflows/generate-diff.yml<pre><code>name: Generate Diff\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  generate-diff:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            dagandersen/argocd-diff-preview:v0.1.24 \\\n            --target-branch=refs/pull/${{ github.event.number }}/merge \\\n            --repo=${{ github.repository }} \\\n            --auto-detect-files-changed=true \\\n            --watch-if-no-watch-pattern-found=true\n</code></pre>"},{"location":"application-selection/#approach-2-manual-file-detection","title":"Approach 2: Manual File Detection","text":"<p>For more control over file detection, you can manually detect changed files and pass them to the tool using the <code>--files-changed</code> option or <code>FILES_CHANGED</code> environment variable. This approach is useful if you have custom logic for determining which files matter.</p> <p>How it works: - Use a GitHub Action like <code>tj-actions/changed-files</code> to detect changed files - Pass the file list to <code>argocd-diff-preview</code> - Only applications with matching <code>watch-pattern</code> annotations will be rendered - Applications without a <code>watch-pattern</code> annotation follow the <code>--watch-if-no-watch-pattern-found</code> setting</p> .github/workflows/generate-diff.yml<pre><code>name: Generate Diff\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  generate-diff:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - name: Get changed files\n        id: changed-files\n        uses: tj-actions/changed-files@v45\n\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            -e FILES_CHANGED=\"${{ steps.changed-files.outputs.all_changed_files }}\" \\\n            dagandersen/argocd-diff-preview:v0.1.24\n</code></pre>"},{"location":"application-selection/#2-ignoring-individual-applications","title":"2. Ignoring Individual Applications","text":"<p>Sometimes you need to permanently exclude specific applications from diff previews. This is useful for applications that: - Are rarely updated and don't need review - Generate very large diffs that aren't useful - Have sensitive information you don't want in pull request comments</p> <p>Add the <code>argocd-diff-preview/ignore: \"true\"</code> annotation to any Application or ApplicationSet manifest to skip it during rendering.</p> <p>Example: Ignoring an Application</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/ignore: \"true\"\nspec:\n  # ...\n</code></pre> <p>Example: Ignoring an ApplicationSet</p> ApplicationSet<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: my-appset\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/ignore: \"true\"\nspec:\n  # ...\n</code></pre> <p>Combining with other filters</p> <p>The ignore annotation takes precedence over other selection methods. An ignored application will never be rendered, even if it matches label selectors or file patterns.</p>"},{"location":"application-selection/#3-label-selectors","title":"3. Label Selectors","text":"<p>Label selectors provide a flexible way to filter applications using Kubernetes labels. This is particularly useful when you organize your applications by team, environment, or criticality.</p> <p>Use the <code>--selector</code> flag with label matching expressions. The tool supports standard Kubernetes label selector operators: - <code>=</code> or <code>==</code> for equality - <code>!=</code> for inequality</p> <p>Example: Filter by team</p> <pre><code>argocd-diff-preview --selector \"team=platform\"\n</code></pre> <p>This command renders only applications with the label <code>team: platform</code>. All applications without this label are skipped.</p> <p>Example: Application with labels</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\n  namespace: argocd\n  labels:\n    team: platform\n    environment: production\nspec:\n  # ...\n</code></pre> <p>Common use cases: - Filter by team: <code>--selector \"team=platform\"</code> - Filter by environment: <code>--selector \"environment=production\"</code> - Exclude specific values: <code>--selector \"criticality!=low\"</code></p> <p>Multiple selectors</p> <p>You can combine multiple label selectors to create more specific filters based on your application organization structure.</p>"},{"location":"application-selection/#4-application-file-path-regex","title":"4. Application File Path Regex","text":"<p>File path regex filtering is useful for targeting applications based on their location in your repository structure. This is especially helpful in monorepos where different teams or projects maintain applications in separate directories.</p> <p>Use the <code>--file-regex</code> flag to specify a regular expression pattern. Only Application and ApplicationSet manifests whose file paths match the pattern will be rendered.</p> <p>Example: Filter by team directory</p> <p>If Team A maintains their applications in a <code>team-a/</code> directory:</p> <pre><code>argocd-diff-preview --file-regex=\"team-a/\"\n</code></pre> <p>This renders only applications whose file paths contain <code>team-a/</code>, such as: - <code>apps/team-a/frontend.yaml</code> - <code>team-a/services/backend.yaml</code> - <code>infrastructure/team-a/database.yaml</code></p> <p>Example: Filter by multiple directories</p> <pre><code>argocd-diff-preview --file-regex=\"(team-a|team-b)/\"\n</code></pre> <p>This renders applications from either <code>team-a/</code> or <code>team-b/</code> directories.</p> <p>Common patterns: - Single team: <code>--file-regex=\"team-a/\"</code> - Multiple teams: <code>--file-regex=\"(team-a|team-b)/\"</code> - Environment-specific: <code>--file-regex=\"production/\"</code> - Exclude directories: <code>--file-regex=\"^(?!.*/deprecated/).*$\"</code></p>"},{"location":"demo/","title":"Try demo locally with 3 simple commands!","text":"<p>First, make sure Docker is running. Run <code>docker ps</code> to check if it's running.</p> <p>Second, run the following 3 commands:</p> <pre><code>git clone https://github.com/dag-andersen/argocd-diff-preview base-branch --depth 1 -q \n\ngit clone https://github.com/dag-andersen/argocd-diff-preview target-branch --depth 1 -q -b helm-example-3\n\ndocker run \\\n   --network host \\\n   -v /var/run/docker.sock:/var/run/docker.sock \\\n   -v $(pwd)/output:/output \\\n   -v $(pwd)/base-branch:/base-branch \\\n   -v $(pwd)/target-branch:/target-branch \\\n   -e TARGET_BRANCH=helm-example-3 \\\n   -e REPO=dag-andersen/argocd-diff-preview \\\n   dagandersen/argocd-diff-preview:v0.1.24\n</code></pre> <p>and the output would be something like this:</p> <pre><code>\u2728 Running with:\n\u2728 - local-cluster-tool: Kind\n\u2728 - base-branch: main\n\u2728 - target-branch: helm-example-3\n\u2728 - secrets-folder: ./secrets\n\u2728 - output-folder: ./output\n\u2728 - repo: dag-andersen/argocd-diff-preview\n\u2728 - timeout: 180 seconds\n\ud83d\ude80 Creating cluster...\n\ud83d\ude80 Cluster created successfully\n\ud83e\udd91 Installing Argo CD Helm Chart version: 'latest'\n\ud83e\udd91 Installing Argo CD Helm Chart\n\ud83e\udd91 Waiting for Argo CD to start...\n\ud83e\udd91 Argo CD is now available\n\ud83e\udd91 Logging in to Argo CD through CLI...\n\ud83e\udd91 Argo CD installed successfully\n\ud83e\udd37 No secrets found in ./secrets\n\ud83e\udd16 Fetching all files in dir: base-branch\n\ud83e\udd16 Patching applications for branch: main\n\ud83e\udd16 Patching 4 Argo CD Application[Sets] for branch: main\n\ud83e\udd16 Fetching all files in dir: target-branch\n\ud83e\udd16 Patching applications for branch: helm-example-3\n\ud83e\udd16 Patching 4 Argo CD Application[Sets] for branch: helm-example-3\n\ud83c\udf1a Getting resources from base\n\u23f3 Waiting for 4 out of 4 applications to become 'OutOfSync'. Retrying in 5 seconds. Timeout in 180 seconds...\n\ud83c\udf1a Got all resources from 4 applications for base\n\ud83e\uddfc Removing applications\n\ud83e\uddfc Removed applications successfully\n\ud83c\udf1a Getting resources from target\n\u23f3 Waiting for 3 out of 4 applications to become 'OutOfSync'. Retrying in 5 seconds. Timeout in 180 seconds...\n\ud83c\udf1a Got all resources from 4 applications for target\n\ud83d\udca5 Deleting cluster...\n\ud83d\udd2e Generating diff between main and helm-example-3\n\ud83d\ude4f Please check the ./output/diff.md file for differences\n\ud83c\udf89 Done in 99 seconds\n</code></pre> <p>Finally, you can view the diff by running <code>cat ./output/diff.md</code>. The diff should look something like this</p> <p>Questions, issues, or suggestions</p> <p>If you experience issues or have any questions, please open an issue in the repository! \ud83d\ude80</p>"},{"location":"design-philosophy/","title":"Design Philosophy","text":"<p>This page outlines the core design principles behind <code>argocd-diff-preview</code>. Understanding these principles will help you understand why the tool works the way it does and what trade-offs have been made.</p> <p>Have a different perspective? Let's talk!</p> <p>These design principles reflect our current thinking, but we're always open to discussion. If you have a different perspective, a use case we haven't considered, or ideas for improvement, please open an issue on GitHub. We welcome the discussion!</p>"},{"location":"design-philosophy/#use-argo-cd-to-render-manifests-dont-reinvent-the-wheel","title":"Use Argo CD to render manifests - Don't reinvent the wheel","text":"<p>Many alternative tools try to mimic or re-implement Argo CD's rendering logic. This is a losing battle because Argo CD's rendering logic is complex and constantly evolving. It supports Helm, Kustomize, plain YAML, Jsonnet, custom plugins, and combinations of all of these. Trying to replicate this logic outside of Argo CD inevitably leads to subtle differences that result in confusing diffs that don't reflect reality.</p> <p>The only way to ensure accurate diffs is to use Argo CD itself to render the manifests.</p>"},{"location":"design-philosophy/#compare-desired-states-not-actual-states","title":"Compare desired states - Not actual states","text":"<p>Unlike some alternative tools or the <code>argocd diff</code> CLI command, <code>argocd-diff-preview</code> does not compare the desired state in Git with the actual state in Kubernetes. Instead, it compares the desired state of two branches - both stored in Git.</p> <p>This is a deliberate design choice. Here's why:</p>"},{"location":"design-philosophy/#the-problem-with-comparing-to-live-state","title":"The problem with comparing to live state","text":"<p>When you compare a Git branch to the live state in a Kubernetes cluster, you introduce non-determinism and ambiguity. The actual state in Kubernetes can differ from the desired state for many reasons:</p> <ul> <li>Temporary drift - Someone made a manual change that will be reverted on next sync</li> <li>Failed syncs - An application failed to sync and is out of date</li> <li>Sync delays - Auto-sync hasn't run yet after a recent merge</li> <li>External controllers - Other controllers (like HPA or VPA) modified resources</li> <li>Admission webhooks - Webhooks injected sidecars or modified resources</li> </ul> <p>This also raises confusing questions: If an application doesn't have auto-sync enabled and is currently out-of-sync, what should the diff show? Should it compare against the \"not-yet-synced\" desired state, or against the manifests that were applied last time the app was synced? These ambiguities make the output hard to trust and reason about.</p> <p>If you've used alternative tools that compare to live state, you've likely experienced this: each time you run the tool, it may produce a different result if the cluster state changes often. This makes it hard to trust the output and leads to confusion during code review.</p>"},{"location":"design-philosophy/#the-benefit-of-comparing-two-git-branches","title":"The benefit of comparing two Git branches","text":"<p>By comparing two Git branches (typically <code>main</code> vs your PR branch), the output is deterministic. Running the tool twice with the same inputs will always produce the same output. This makes the diff:</p> <ul> <li>Trustworthy - Reviewers can rely on what they see</li> <li>Reproducible - You can re-run the tool and get the same result</li> <li>Focused - Shows only the changes introduced by the PR, not unrelated drift</li> </ul>"},{"location":"design-philosophy/#what-about-drift-detection","title":"What about drift detection?","text":"<p>If you need to detect drift between Git and your cluster, that's a different problem with different tools. Argo CD itself has excellent drift detection built-in. The purpose of <code>argocd-diff-preview</code> is to help you review changes before they're merged - not to monitor the state of your cluster.</p>"},{"location":"design-philosophy/#gitops-best-practices","title":"GitOps best practices","text":"<p>This design assumes GitOps best practices where auto-sync is enabled and Git is the source of truth. If changes merged to <code>main</code> are automatically applied to your cluster, then you don't need to compare your PR branch to the live cluster state - you only need to compare it to <code>main</code>, because <code>main</code> is the live state (or will be shortly after merge).</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#does-the-tool-work-with-applicationsets","title":"Does the tool work with <code>ApplicationSets</code>?","text":"<p>Short answer: Yes.</p> <p>Longer Answer: Yes, but how well it works depends on the complexity of your generators.</p> <ul> <li> <p>List generator:   Yes, no issues reported</p> </li> <li> <p>Cluster generator:   Yes, but you have to add the ClusterSecrets to the <code>secrets</code> folder. Similar to how the secrets are provided here</p> </li> <li> <p>Git generator:   Yes, no issues reported</p> </li> <li> <p>Matrix generator:   Yes, no issues reported</p> </li> <li> <p>Merge generator:   Yes, no issues reported</p> </li> <li> <p>Plugin generator:    Should work, but not tested. Read more on how to install a plugin here. Related Issue: #40</p> </li> <li> <p>Pull Request generator:    Should work, but not tested.</p> </li> <li> <p>SCM Provider generator:   Not tested</p> </li> <li> <p>Cluster Decision Resource generator:   Not tested</p> </li> </ul>"},{"location":"faq/#does-it-work-with-config-management-plugins-cmp","title":"Does it work with Config Management Plugins (CMP)","text":"<p>Yes. More info here</p>"},{"location":"faq/#does-it-work-with-git-providers-other-than-github-and-gitlab","title":"Does it work with Git providers other than GitHub and GitLab?","text":"<p>Short answer: Yes.</p> <p>Longer answer: In theory, yes, but not all providers have been tested. If you are using a different Git provider and encounter issues, please open an issue in the repository. Additionally, if you have successfully used the tool with a different provider, consider contributing to the documentation so others can benefit from a working example \u2764\ufe0f</p> <p>Relevant issue: #94</p>"},{"location":"faq/#why-not-compare-the-pr-branch-to-the-live-cluster-state","title":"Why not compare the PR branch to the live cluster state?","text":"<p>Comparing to live cluster state introduces non-determinism and ambiguity. The cluster state can change between runs, making the output unreliable and hard to trust during code review. Read more about this in the Design Philosophy.</p>"},{"location":"faq/#does-it-work-with-the-apps-of-apps-pattern","title":"Does it work with the Apps of Apps Pattern?","text":"<p>Short answer: Yes, but it depends on your setup.</p> <p>Longer answer: The Apps of Apps Pattern can be configured in many ways, making it challenging to handle all cases. This tool identifies and renders all resources with <code>kind: Application</code> or <code>kind: ApplicationSet</code>. If your Applications or ApplicationSets are written as plain manifests in your repository, the tool will work seamlessly. However, if you have an Application that deploys a Helm chart, which then deploys the rest of your Applications, you will need to render the Helm chart before running the tool.</p> <p>Relevant issue: #75</p>"},{"location":"faq/#why-cant-the-tool-automatically-render-my-helm-charts-or-kustomize-templates","title":"Why can't the tool automatically render my Helm Charts or Kustomize templates?","text":"<p>Helm and Kustomize configurations are inherently complex:</p> <ul> <li>Helm: Any YAML file can be used as a values file for Helm charts, making it impossible for the tool to automatically determine which YAML files should be used as values files and which Helm charts they belong to.</li> <li>Kustomize: Overlays in Kustomize can be chained in various ways. The tool cannot reliably figure out which overlays to use or skip.</li> </ul> <p>Because of this, users must render their Helm charts and Kustomize templates before running the tool.</p> <p>The tool is rather conservative in making assumptions about how Applications are rendered, with the goal of avoiding false positives.</p> <p>More info: docs</p>"},{"location":"faq/#does-it-work-with-a-distributed-argo-cd-repository-setup-multi-repo","title":"Does it work with a distributed Argo CD repository setup? (Multi-repo)","text":"<p>Short answer: Yes</p> <p>Longer answer: Yes, but it deepends on how complicated your setup is. Check out the multi-repo documentation to learn how to use the tool with a distributed Argo CD repository setup.</p>"},{"location":"faq/#how-do-i-speed-up-the-tool","title":"How do I speed up the tool?","text":"<p>Short answer: Connect to a pre-installed Argo CD instance and limit the number of applications rendered.</p> <p>Longer answer: There are two main ways to speed up the tool:</p> <ol> <li> <p>Connect to a pre-installed Argo CD instance: Instead of creating an ephemeral cluster for each run, connect to a pre-installed Argo CD instance. This saves ~60-90 seconds per run. See Connecting to a cluster with Argo CD pre-installed.</p> </li> <li> <p>Limit applications rendered: Rendering the manifests for all applications in the repository on each pull request can be time-consuming. Limiting the number of applications rendered can significantly speed up the process. By default, <code>argocd-diff-preview</code> renders all applications in the repository. Check out Application Selection to learn how to limit the number of applications rendered.</p> </li> </ol>"},{"location":"filter-output/","title":"Filter Diff Output","text":"<p>This page explains how to reduce noise in your diff output by ignoring specific lines or entire resources.</p>"},{"location":"filter-output/#ignore-specific-lines","title":"Ignore specific lines","text":"<p>Use the <code>--diff-ignore</code> option to hide lines matching a regex pattern.</p>"},{"location":"filter-output/#example-image-tag-changes","title":"Example: Image tag changes","text":"<p>Since this tool highlights diffs between branches, it's important to stay up to date with your main branch. If your main branch is updated frequently with new container image tags, you'll see a lot of noise in the diff - changes like <code>image: my-image:v1.0.0</code> \u2192 <code>image: my-image:v1.0.1</code> will appear in every PR:</p> <pre><code>diff --git base/deployment target/deployment\n@@ -3,38 +3,38 @@ template:\n    spec:\n      containers:\n        - name: my-app\n-         image: dag-andersen/my-app:v1.0.1\n+         image: dag-andersen/my-app:v1.0.2\n          ports:\n            - containerPort: 80\n</code></pre> <p>To hide these, use a regex that matches version strings:</p> <pre><code>argocd-diff-preview --diff-ignore=\"v[0-9]+\\.[0-9]+\\.[0-9]+\"\n</code></pre>"},{"location":"filter-output/#example-helm-generated-values","title":"Example: Helm-generated values","text":"<p>Some Helm charts generate new values on every install (certificates, random strings, etc.). These appear in every PR even when nothing meaningful changed:</p> <pre><code>   name: example-name\n webhooks:\n - admissionReviewVersions:\n   - v1\n   clientConfig:\n-    caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURLR ...\n+    caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURKe ...\n     service:\n       name: example-name\n       port: 443\n   failurePolicy: Fail\n   name: vbinding.kb.io\n</code></pre> <pre><code>argocd-diff-preview --diff-ignore=\"caBundle\"\n</code></pre> <p>This hides all lines containing the word <code>caBundle</code>.</p>"},{"location":"filter-output/#ignore-resources","title":"Ignore resources","text":"<p>Use <code>--ignore-resources</code> to exclude entire resources from the diff. The format is:</p> <pre><code>group:kind:name\n</code></pre> Component Description <code>group</code> API group (empty = core group, <code>*</code> = any) <code>kind</code> Resource kind (<code>*</code> = any) <code>name</code> Resource name (<code>*</code> = any)"},{"location":"filter-output/#example","title":"Example","text":"<pre><code>argocd-diff-preview --ignore-resources=\"apps:Deployment:my-deploy,*:CustomResourceDefinition:*,:ConfigMap:argocd-cm\"\n</code></pre> <p>This hides:</p> <ul> <li>The Deployment named <code>my-deploy</code> in the <code>apps</code> group</li> <li>All CustomResourceDefinitions (any group)</li> <li>The ConfigMap named <code>argocd-cm</code> in the core group</li> </ul>"},{"location":"generated-applications/","title":"Helm/Kustomize generated ArgoCD applications","text":"<p><code>argocd-diff-preview</code> will only look for YAML files in the repository with <code>kind: Application</code> or <code>kind: ApplicationSet</code>. If your applications are generated from a Helm chart or Kustomize template, you will have to add a step in the pipeline that renders the chart/template.</p> <p>Helm and Kustomize examples:</p> <p>.github/workflows/generate-diff.yml<pre><code>jobs:\n  build:\n    ...\n    steps:\n      ...\n    - uses: actions/checkout@v4\n      with:\n        path: pull-request\n\n    - name: Generate with helm chart\n      run: helm template pull-request/some/path/my-chart &gt; pull-request/rendered-apps.yaml\n\n    - name: Generate with kustomize\n      run: kustomize build pull-request/some/path/my-kustomize &gt; pull-request/rendered-apps.yaml\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          ...\n</code></pre> This will place the rendered manifests inside the <code>pull-request</code> folder, and the tool will pick them up.</p>"},{"location":"how-it-works/","title":"How it works","text":"<p>This page describes how <code>argocd-diff-preview</code> works under the hood.</p> <p>The tool follows a simple but powerful approach: use a real Argo CD instance to render your manifests and compare the results between branches. This ensures the diff is 100% accurate - exactly what Argo CD would produce in your real cluster.</p>"},{"location":"how-it-works/#modes","title":"Modes","text":""},{"location":"how-it-works/#ephemeral-cluster-mode","title":"Ephemeral Cluster Mode","text":""},{"location":"how-it-works/#pre-installed-argo-cd-mode","title":"Pre-installed Argo CD Mode","text":"<p>When you run the tool, it follows these steps:</p>"},{"location":"how-it-works/#step-1-fetch-applications","title":"Step 1: Fetch Applications","text":"<p>The tool collects all resources from the <code>base-branch</code> and <code>target-branch</code> folders for all YAML files containing:</p> <ul> <li><code>kind: Application</code></li> <li><code>kind: ApplicationSet</code></li> </ul>"},{"location":"how-it-works/#step-2-selectfilter-applications","title":"Step 2: Select/Filter Applications","text":"<p>Before processing, the tool filters which applications to render. By default, all applications are rendered, but you can limit this using several strategies:</p> Strategy How it works Watch patterns Add <code>argocd-diff-preview/watch-pattern</code> annotation to only render apps when specific files change Ignore annotation Add <code>argocd-diff-preview/ignore: \"true\"</code> to skip specific applications entirely Label selectors Use <code>--selector \"team=platform\"</code> to filter by Kubernetes labels File path regex Use <code>--file-regex=\"team-a/\"</code> to filter by the application's file location <p>This is especially useful in large monorepos where rendering all applications on every PR would be slow. See Application Selection for more details.</p> <p>Early exit if no applications selected</p> <p>If no applications are selected after filtering, the tool stops here and outputs an empty diff. This avoids spinning up a cluster unnecessarily.</p>"},{"location":"how-it-works/#step-3-patch-applications","title":"Step 3: Patch Applications","text":"<p>For each Application or ApplicationSet found, it applies the following modifications:</p> Modification Why Set <code>metadata.namespace</code> to <code>argocd</code> So Argo CD can find and manage the applications. This is overridden by the <code>--argocd-namespace</code> flag. Remove <code>spec.syncPolicy</code> Prevents Argo CD from actually syncing resources to the cluster Set <code>spec.project</code> to <code>default</code> The ephemeral Argo CD only has the <code>default</code> project configured Set <code>spec.destination.server</code> to <code>https://kubernetes.default.svc</code> Points to the local cluster (the actual destination doesn't matter since we're only rendering, not syncing) Set <code>spec.source.targetRevision</code> to the branch name So Argo CD renders manifests from the correct branch Set <code>spec.sources[*].targetRevision</code> to the branch name Same as above, but for multi-source applications Set <code>spec.generators[*].git.revision</code> to the branch name For ApplicationSets using Git generators (including nested Matrix/Merge generators) <p> </p> <p>Steps 4-6: Ephemeral Cluster Mode Only</p> <p>Steps 4, 5, and 6 only apply when using the default ephemeral cluster mode. If you're connecting to a pre-installed Argo CD instance with <code>--create-cluster=false</code>, these steps are skipped and the tool connects directly to your pre-installed Argo CD.</p>"},{"location":"how-it-works/#step-4-start-local-cluster","title":"Step 4: Start local cluster","text":"<p>The tool creates a local ephemeral Kubernetes cluster using one of the supported local cluster tools:</p> <ul> <li>Kind (default)</li> <li>Minikube</li> <li>k3d</li> </ul> <p><code>argocd-diff-preview</code> practically just runs: </p> <pre><code>kind create cluster --name argocd-diff-preview\n</code></pre>"},{"location":"how-it-works/#step-5-install-argo-cd","title":"Step 5: Install Argo CD","text":"<p>Argo CD is installed using the official Argo CD Helm Chart. By default, the latest version is installed, but you can specify a version with <code>--argocd-chart-version</code>.</p> <p>You can customize the installation by mounting a <code>values.yaml</code> file. This is useful for:</p> <ul> <li>Enabling Config Management Plugins (CMPs)</li> <li>Configuring Kustomize build options</li> <li>Any other Argo CD Helm chart customization</li> </ul> <p>See Custom Argo CD Installation for details.</p> <p><code>argocd-diff-preview</code> practically just runs:</p> <pre><code>helm install my-argo-cd argo/argo-cd --version x.x.x\n</code></pre>"},{"location":"how-it-works/#step-6-apply-credentials","title":"Step 6: Apply credentials","text":"<p>If your repository is private, you need to provide the tool with the necessary credentials.</p> <p>You can do this by mounting a <code>/secrets</code> folder:</p> Example: GitHub Actions workflow with secrets <pre><code>- name: Prepare secrets\n  run: |\n    mkdir secrets\n    cat &gt; secrets/secret.yaml &lt;&lt; \"EOF\"\n    apiVersion: v1\n    kind: Secret\n    metadata:\n      name: private-repo\n      namespace: argocd\n      labels:\n        argocd.argoproj.io/secret-type: repo-creds\n    stringData:\n      url: https://github.com/${{ github.repository }}\n      password: ${{ secrets.GITHUB_TOKEN }}  \u2b05\ufe0f Short-lived GitHub Token\n      username: not-used\n    EOF\n\n- name: Generate Diff\n  run: |\n    docker run \\\n      --network=host \\\n      -v /var/run/docker.sock:/var/run/docker.sock \\\n      -v $(pwd)/main:/base-branch \\\n      -v $(pwd)/pull-request:/target-branch \\\n      -v $(pwd)/output:/output \\\n      -v $(pwd)/secrets:/secrets \\           \u2b05\ufe0f Mount the secrets folder\n      -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n      -e REPO=${{ github.repository }} \\\n      dagandersen/argocd-diff-preview:v0.1.24\n</code></pre> <p>All resources in the <code>/secrets</code> folder are applied to the cluster. The relevant secrets are typically included in the <code>/secrets</code> folder:</p> <ul> <li>Repository credentials - For accessing private Git repositories</li> <li>Helm chart credentials - For private Helm registries (including OCI)</li> <li>Cluster secrets - For ApplicationSets using the Cluster generator</li> </ul> <p>These secrets use the standard Argo CD secret format.</p> <p><code>argocd-diff-preview</code> practically just runs:</p> <pre><code>kubectl apply -f /secrets\n</code></pre>"},{"location":"how-it-works/#step-7-generate-applications-from-applicationsets","title":"Step 7: Generate Applications from ApplicationSets","text":"<p>For each ApplicationSet found, it generates the applications using the Argo CD CLI:</p> <pre><code>argocd appset generate &lt;app-set-name&gt;\n</code></pre> <p>This returns a list of applications.</p> <p>The newly generated applications also go through <code>Step 2</code> and <code>Step 3</code> (filtering and patching).</p>"},{"location":"how-it-works/#step-8-apply-applications-to-the-cluster","title":"Step 8: Apply applications to the cluster","text":"<p>The patched applications are applied to the cluster.</p> <p><code>argocd-diff-preview</code> practically just runs:</p> <pre><code>kubectl apply -f &lt;patched-applications&gt;\n</code></pre> <p>At this point, Argo CD starts processing each application - rendering the applications.</p>"},{"location":"how-it-works/#step-9-wait-for-argo-cd-to-render","title":"Step 9: Wait for Argo CD to render","text":"<p>The tool will repeatedly check the status of each application and extract the rendered manifests as they become ready.</p> <p>The tool will poll the applications until they're ready or the timeout is reached (default: 180 seconds).</p> <p>It practically just waits for the Application to look like this:</p> <p> </p>"},{"location":"how-it-works/#step-10-extract-rendered-manifests","title":"Step 10: Extract rendered manifests","text":"<p>Once applications are ready, the tool extracts the rendered manifests using the Argo CD CLI:</p> <pre><code>argocd app manifests &lt;app-name&gt;\n</code></pre> <p>This returns the exact YAML generated by the applications - fully rendered with all Helm values substituted and Kustomize patches applied.</p>"},{"location":"how-it-works/#step-11-generate-the-diff","title":"Step 11: Generate the diff","text":"<p>The tool compares the two sets of manifests and generates a diff. The comparison is done per-application, showing:</p> <ul> <li>Added applications - New in target branch</li> <li>Removed applications - Deleted in target branch  </li> <li>Modified applications - Changed between branches</li> <li>Unchanged applications - No differences (not shown in output)</li> </ul> <p>The diff respects the <code>--diff-ignore</code> option to filter out noisy changes. Documentation: Ignore specific lines in the diff preview</p>"},{"location":"how-it-works/#step-12-output-the-results","title":"Step 12: Output the results","text":"<p>The tool writes several files to the output folder (<code>./output/</code> by default):</p> File Description <code>./output/diff.md</code> Markdown diff - ready to post as a PR comment <code>./output/diff.html</code> HTML diff - visual side-by-side comparison <code>./output/base-branch.yaml</code> Single manifest with all rendered resources from base branch <code>./output/target-branch.yaml</code> Single manifest with all rendered resources from target branch <code>./output/base/&lt;app-name&gt;.yaml</code> Individual manifests for each app rendered from base branch <code>./output/target/&lt;app-name&gt;.yaml</code> Individual manifests for each app rendered from target branch <p>The Markdown output is designed to be posted directly to your pull request using <code>gh pr comment</code> or equivalent.</p>"},{"location":"multi-repo/","title":"Multi-repo support","text":"<p>This page explains how to use <code>argocd-diff-preview</code> when your Argo CD Applications and their managed Kubernetes resources live in separate repositories.</p>"},{"location":"multi-repo/#terminology","title":"Terminology","text":"<p>Let's define the two repositories we're working with:</p> Repository Contains Application Repository Argo CD <code>Application</code> and <code>ApplicationSet</code> manifests Resource Repository Kubernetes resources (Helm charts, Kustomize overlays, plain YAML) referenced by the applications <p>If you want diffs triggered by changes in either repository, you'll need a pipeline in both.</p>"},{"location":"multi-repo/#two-key-rules","title":"Two key rules","text":""},{"location":"multi-repo/#rule-1-repo-must-match-the-repository-with-the-pr","title":"Rule 1: <code>--repo</code> must match the repository with the PR","text":"<p>The <code>--repo</code> flag tells <code>argocd-diff-preview</code> which repository has the change. The tool uses this to redirect the correct <code>targetRevision</code> to the PR branch.</p> Flag Purpose <code>--repo</code> Must match the repository where the PR was opened <code>--target-branch</code> The PR branch that applications should be redirected to <pre><code>docker run \\\n  --network=host \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v $(pwd)/main:/base-branch \\\n  -v $(pwd)/pull-request:/target-branch \\\n  -v $(pwd)/output:/output \\\n  -e REPO=&lt;org&gt;/&lt;repo-with-pr&gt; \\            \u2b05\ufe0f Must match the repo with the PR\n  -e TARGET_BRANCH=&lt;pr-branch&gt; \\            \u2b05\ufe0f The branch to redirect applications to\n  dagandersen/argocd-diff-preview:v0.1.24\n</code></pre> <p>Why does this matter?</p> <p>The tool only redirects applications whose <code>spec.source.repoURL</code> matches the <code>--repo</code> flag. If you specify the wrong repo, the applications won't point to your PR branch.</p>"},{"location":"multi-repo/#rule-2-always-clone-the-application-repository","title":"Rule 2: Always clone the Application Repository","text":"<p>The <code>/base-branch</code> and <code>/target-branch</code> folders must contain the Application Repository - this is where <code>argocd-diff-preview</code> looks for <code>Application</code> and <code>ApplicationSet</code> manifests.</p> <p>This means even when running a pipeline in the Resource Repository, you still need to clone the Application Repository into these folders.</p>"},{"location":"multi-repo/#github-workflows-examples","title":"GitHub Workflows Examples","text":""},{"location":"multi-repo/#pipeline-in-the-application-repository","title":"Pipeline in the Application Repository","text":"<p>This is the standard setup - nothing unusual here:</p> <ul> <li>Clone the Application Repository (this repo)</li> <li>Provide secrets for both repositories</li> <li>Set <code>--repo</code> to the Application Repository</li> </ul> .github/workflows/diff.yml (Application Repository)<pre><code>name: Argo CD Diff Preview\n\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4       \u2b05\ufe0f We pull the Application Repository\n        with:\n          path: pull-request\n\n      - uses: actions/checkout@v4       \u2b05\ufe0f We pull the Application Repository\n        with:\n          ref: main\n          path: main\n\n      - name: Prepare secrets\n        run: |\n          mkdir secrets\n\n          # Secret for Application Repository\n          cat &gt; secrets/app-repo-creds.yaml &lt;&lt; \"EOF\"\n          apiVersion: v1\n          kind: Secret\n          metadata:\n            name: app-repo-creds\n            namespace: argocd\n            labels:\n              argocd.argoproj.io/secret-type: repo-creds\n          stringData:\n            url: https://github.com/&lt;org&gt;/&lt;application-repository&gt;\n            password: ${{ secrets.GITHUB_TOKEN }}\n            username: not-used\n          EOF\n\n          # Secret for Resource Repository\n          cat &gt; secrets/resource-repo-creds.yaml &lt;&lt; \"EOF\"\n          apiVersion: v1\n          kind: Secret\n          metadata:\n            name: resource-repo-creds\n            namespace: argocd\n            labels:\n              argocd.argoproj.io/secret-type: repo-creds\n          stringData:\n            url: https://github.com/&lt;org&gt;/&lt;resource-repository&gt;\n            password: ${{ secrets.RESOURCE_REPO_TOKEN }}\n            username: not-used\n          EOF\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -v $(pwd)/secrets:/secrets \\               \u2b05\ufe0f Mount the secrets folder\n            -e TARGET_BRANCH=&lt;pr-branch&gt; \\             \u2b05\ufe0f The PR branch on the Application Repository\n            -e REPO=&lt;org&gt;/&lt;application-repository&gt; \\   \u2b05\ufe0f Application Repository\n            dagandersen/argocd-diff-preview:v0.1.24\n\n      - name: Post diff as comment\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"multi-repo/#local-equivalent","title":"Local equivalent","text":"<pre><code>git clone https://github.com/&lt;org&gt;/&lt;application-repository&gt; base-branch --depth 1 -q -b main\ngit clone https://github.com/&lt;org&gt;/&lt;application-repository&gt; target-branch --depth 1 -q -b pr-branch\n\nmkdir secrets\n# store some secrets in the ./secrets folder\n\ndocker run \\\n    --network host \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v $(pwd)/output:/output \\\n    -v $(pwd)/base-branch:/base-branch \\\n    -v $(pwd)/target-branch:/target-branch \\\n    -v $(pwd)/secrets:/secrets \\\n    -e TARGET_BRANCH=&lt;pr-branch&gt; \\\n    -e REPO=&lt;org&gt;/&lt;application-repository&gt; \\\n    dagandersen/argocd-diff-preview:v0.1.24\n</code></pre>"},{"location":"multi-repo/#pipeline-in-the-resource-repository","title":"Pipeline in the Resource Repository","text":"<p>This is where it gets interesting:</p> <ul> <li>Clone the Application Repository (not the current repo!)</li> <li>Provide secrets for both repositories  </li> <li>Set <code>--repo</code> to the Resource Repository (where the PR is)</li> </ul> .github/workflows/diff.yml (Resource Repository)<pre><code>name: Argo CD Diff Preview\n\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      # \u26a0\ufe0f Clone the APPLICATION Repository, not this Resource Repository!\n      # Both clone `main` because the PR is not on the Application Repository\n      - uses: actions/checkout@v4\n        with:\n          repository: &lt;org&gt;/&lt;application-repository&gt;\n          token: ${{ secrets.APP_REPO_TOKEN }}\n          ref: main\n          path: pull-request\n\n      - uses: actions/checkout@v4\n        with:\n          repository: &lt;org&gt;/&lt;application-repository&gt;\n          token: ${{ secrets.APP_REPO_TOKEN }}\n          ref: main\n          path: main\n\n      - name: Prepare secrets\n        run: |\n          mkdir secrets\n\n          # Secret for Application Repository\n          cat &gt; secrets/app-repo-creds.yaml &lt;&lt; \"EOF\"\n          apiVersion: v1\n          kind: Secret\n          metadata:\n            name: app-repo-creds\n            namespace: argocd\n            labels:\n              argocd.argoproj.io/secret-type: repo-creds\n          stringData:\n            url: https://github.com/&lt;org&gt;/&lt;application-repository&gt;\n            password: ${{ secrets.APP_REPO_TOKEN }}\n            username: not-used\n          EOF\n\n          # Secret for Resource Repository\n          cat &gt; secrets/resource-repo-creds.yaml &lt;&lt; \"EOF\"\n          apiVersion: v1\n          kind: Secret\n          metadata:\n            name: resource-repo-creds\n            namespace: argocd\n            labels:\n              argocd.argoproj.io/secret-type: repo-creds\n          stringData:\n            url: https://github.com/&lt;org&gt;/&lt;resource-repository&gt;\n            password: ${{ secrets.GITHUB_TOKEN }}\n            username: not-used\n          EOF\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -v $(pwd)/secrets:/secrets \\               \u2b05\ufe0f Mount the secrets folder\n            -e TARGET_BRANCH=&lt;pr-branch&gt; \\             \u2b05\ufe0f The PR branch on the Resource Repository\n            -e REPO=&lt;org&gt;/&lt;resource-repository&gt; \\      \u2b05\ufe0f Resource Repository (where the PR is!)\n            dagandersen/argocd-diff-preview:v0.1.24\n\n      - name: Post diff as comment\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Cross-repository access</p> <p>The Resource Repository pipeline needs a Personal Access Token (PAT) or GitHub App token with access to the Application Repository. The default <code>GITHUB_TOKEN</code> only has access to the current repository.</p>"},{"location":"multi-repo/#local-equivalent_1","title":"Local equivalent","text":"<pre><code>git clone https://github.com/&lt;org&gt;/&lt;application-repository&gt; base-branch --depth 1 -q -b main\ngit clone https://github.com/&lt;org&gt;/&lt;application-repository&gt; target-branch --depth 1 -q -b main\n\nmkdir secrets\n# store some secrets in the ./secrets folder\n\ndocker run \\\n    --network host \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v $(pwd)/output:/output \\\n    -v $(pwd)/base-branch:/base-branch \\\n    -v $(pwd)/target-branch:/target-branch \\\n    -v $(pwd)/secrets:/secrets \\\n    -e TARGET_BRANCH=&lt;pr-branch&gt; \\\n    -e REPO=&lt;org&gt;/&lt;resource-repository&gt; \\\n    dagandersen/argocd-diff-preview:v0.1.24\n</code></pre>"},{"location":"multi-repo/#summary","title":"Summary","text":"Pipeline location Clone which repo? <code>--repo</code> flag Application Repository Application Repository Application Repository Resource Repository Application Repository Resource Repository <p>With pipelines in both repositories, you'll get diffs for changes to either your Applications or the resources they manage.</p> <p>Questions?</p> <p>If you have questions or suggestions, please open an issue!</p>"},{"location":"options/","title":"Options","text":"<p>This document describes all the available options for <code>argocd-diff-preview</code>. Options can be provided via command-line flags or environment variables.</p>"},{"location":"options/#usage","title":"Usage","text":"<pre><code>argocd-diff-preview [FLAGS] [OPTIONS] --repo &lt;repo&gt; --target-branch &lt;target-branch&gt;\n</code></pre>"},{"location":"options/#required-options","title":"Required Options","text":"Flag Environment Variable Description <code>--repo &lt;repo&gt;</code> <code>REPO</code> Git Repository in format <code>OWNER/REPO</code> (e.g., <code>dag-andersen/argocd-diff-preview</code>) <code>--target-branch &lt;target-branch&gt;</code>, <code>-t</code> <code>TARGET_BRANCH</code> Target branch name (the branch you want to compare with the base branch)"},{"location":"options/#flags","title":"Flags","text":"Flag Environment Variable Default Description <code>--create-cluster</code> <code>CREATE_CLUSTER</code> <code>true</code> Create a new cluster if it doesn't exist <code>--disable-client-throttling</code> <code>DISABLE_CLIENT_THROTTLING</code> <code>false</code> Disable client-side throttling (rely on API Priority and Fairness instead) <code>--auto-detect-files-changed</code> <code>AUTO_DETECT_FILES_CHANGED</code> <code>false</code> Auto detect files changed between branches <code>--watch-if-no-watch-pattern-found</code> <code>WATCH_IF_NO_WATCH_PATTERN_FOUND</code> <code>false</code> Render applications without watch-pattern annotation <code>--debug</code>, <code>-d</code> <code>DEBUG</code> <code>false</code> Activate debug mode <code>--dry-run</code> <code>DRY_RUN</code> <code>false</code> Show which applications would be processed without creating a cluster or generating a diff <code>--hide-deleted-app-diff</code> <code>HIDE_DELETED_APP_DIFF</code> <code>false</code> Hide diff content for deleted applications (only show deletion header) <code>--ignore-invalid-watch-pattern</code> <code>IGNORE_INVALID_WATCH_PATTERN</code> <code>false</code> Ignore invalid watch-pattern Regex on Applications <code>--keep-cluster-alive</code> <code>KEEP_CLUSTER_ALIVE</code> <code>false</code> Keep cluster alive after the tool finishes <code>--kind-internal</code> <code>KIND_INTERNAL</code> <code>false</code> Use the kind cluster's internal address in the kubeconfig (allows connecting to the cluster when running the CLI in a container) <code>--use-argocd-api</code> <code>USE_ARGOCD_API</code> <code>false</code> Use Argo CD API instead of CLI (useful for namespace-scoped Argo CD installations) <code>--version</code>, <code>-v</code> - - Prints version information"},{"location":"options/#options_1","title":"Options","text":"Option Environment Variable Default Description <code>--argocd-chart-version &lt;version&gt;</code> <code>ARGOCD_CHART_VERSION</code> <code>latest</code> Argo CD Helm Chart version <code>--argocd-chart-name &lt;name&gt;</code> <code>ARGOCD_CHART_NAME</code> <code>argo</code> Argo CD Helm Chart name <code>--argocd-chart-url &lt;url&gt;</code> <code>ARGOCD_CHART_URL</code> <code>https://argoproj.github.io/argo-helm</code> Argo CD Helm Chart URL <code>--argocd-chart-repo-username &lt;username&gt;</code> <code>ARGOCD_CHART_REPO_USERNAME</code> - Argo CD Helm Chart Private repository username <code>--argocd-chart-repo-password &lt;password&gt;</code> <code>ARGOCD_CHART_REPO_PASSWORD</code> - Argo CD Helm Chart Private repository password <code>--argocd-login-options &lt;options&gt;</code> <code>ARGOCD_LOGIN_OPTIONS</code> - Additional options to pass to <code>argocd login</code> command <code>--argocd-auth-token &lt;token&gt;</code> <code>ARGOCD_AUTH_TOKEN</code> - Argo CD authentication token (skips default admin login) <code>--argocd-namespace &lt;namespace&gt;</code> <code>ARGOCD_NAMESPACE</code> <code>argocd</code> Namespace to use for Argo CD <code>--argocd-ui-url &lt;url&gt;</code> <code>ARGOCD_UI_URL</code> - Argo CD URL to generate application links in diff output (e.g., https://argocd.example.com) <code>--base-branch &lt;branch&gt;</code>, <code>-b</code> <code>BASE_BRANCH</code> <code>main</code> Base branch name <code>--cluster &lt;tool&gt;</code> <code>CLUSTER</code> <code>auto</code> Local cluster tool. Options: <code>kind</code>, <code>minikube</code>, <code>k3d</code>, <code>auto</code> <code>--cluster-name &lt;name&gt;</code> <code>CLUSTER_NAME</code> <code>argocd-diff-preview</code> Cluster name (only for kind &amp; k3d) <code>--diff-ignore &lt;pattern&gt;</code>, <code>-i</code> <code>DIFF_IGNORE</code> - Ignore lines in diff. Example: <code>v[1,9]+.[1,9]+.[1,9]+</code> for ignoring version changes <code>--file-regex &lt;regex&gt;</code>, <code>-r</code> <code>FILE_REGEX</code> - Regex to filter files. Example: <code>/apps_.*\\.yaml</code> <code>--files-changed &lt;files&gt;</code> <code>FILES_CHANGED</code> - List of files changed between branches (comma, space or newline separated) <code>--ignore-resources &lt;rules&gt;</code> <code>IGNORE_RESOURCES</code> - Ignore resources in diff. Format: <code>group:kind:name</code> (comma-separated, <code>*</code> wildcard) <code>--k3d-options &lt;options&gt;</code> <code>K3D_OPTIONS</code> - k3d options (only for k3d) <code>--kind-options &lt;options&gt;</code> <code>KIND_OPTIONS</code> - kind options (only for kind) <code>--line-count &lt;count&gt;</code>, <code>-c</code> <code>LINE_COUNT</code> <code>7</code> Generate diffs with \\&lt;n&gt; lines of context <code>--log-format &lt;format&gt;</code> <code>LOG_FORMAT</code> <code>human</code> Log format. Options: <code>human</code>, <code>json</code> <code>--max-diff-length &lt;length&gt;</code> <code>MAX_DIFF_LENGTH</code> <code>65536</code> Max diff message character count (only limits the generated Markdown file) <code>--output-folder &lt;folder&gt;</code>, <code>-o</code> <code>OUTPUT_FOLDER</code> <code>./output</code> Output folder where the diff will be saved <code>--redirect-target-revisions &lt;revs&gt;</code> <code>REDIRECT_TARGET_REVISIONS</code> - List of target revisions to redirect <code>--secrets-folder &lt;folder&gt;</code>, <code>-s</code> <code>SECRETS_FOLDER</code> <code>./secrets</code> Secrets folder where the secrets are read from <code>--selector &lt;selector&gt;</code>, <code>-l</code> <code>SELECTOR</code> - Label selector to filter on (e.g., <code>key1=value1,key2=value2</code>) <code>--timeout &lt;seconds&gt;</code> <code>TIMEOUT</code> <code>180</code> Set timeout in seconds <code>--title &lt;title&gt;</code> <code>TITLE</code> <code>Argo CD Diff Preview</code> Custom title for the markdown output"},{"location":"output/","title":"Output formats","text":""},{"location":"output/#markdown","title":"Markdown","text":"<p>The tool creates a Markdown file at <code>./output/diff.md</code>.</p> <p></p>"},{"location":"output/#html","title":"HTML","text":"<p>The tool creates an HTML file at <code>./output/diff.html</code>.</p> <p></p>"},{"location":"output/#fully-rendered-manifests","title":"Fully rendered manifests","text":"<p>After rendering the manifests for each branch, the tool stores the compared output in two files: <code>./output/base-branch.yaml</code> and <code>./output/target-branch.yaml</code>. These files are long YAML documents containing all the rendered manifests.</p> <p>You can pass this output into any tool you like. For example, you could feed those files into kube-score to check whether the score of your new branch goes up or down.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#debug-mode","title":"Debug Mode","text":"<p>If you are having trouble with the tool, you can enable debug mode to get more information about what is going wrong. To enable debug mode run the tool with the <code>--debug</code> flag.</p> <p>If that doesn't help or you still have questions, please open an issue in the repository!</p>"},{"location":"troubleshooting/#client-side-throttling","title":"Client-Side Throttling","text":"<p>By default, the Kubernetes client uses client-side rate limiting (QPS: 20, Burst: 40) to avoid overwhelming the API server. If you're running against a cluster with API Priority and Fairness (APF) enabled (Kubernetes 1.20+), you can disable client-side throttling and let the server handle rate limiting instead:</p> <pre><code>argocd-diff-preview --disable-client-throttling ...\n</code></pre> <p>This can improve performance when the cluster's APF configuration allows higher request rates than the client-side defaults.</p>"},{"location":"getting-started/custom-argo-cd-installation/","title":"Custom Argo CD Installation","text":"<p>Argo CD is installed using a Helm Chart. You can specify the Chart version with the <code>--argocd-chart-version</code> option. It defaults to the latest version.</p> <p>You can modify the Argo CD Helm Chart installation by providing the tool with a <code>values.yaml</code> file and mounting it in the <code>argocd-config</code> folder within the container. Check out all the available values in the Argo CD Helm Chart.</p> <p>Example:</p> <p>Here we set <code>configs.cm.\"kustomize.buildOptions\"</code> in the Chart.</p> .github/workflows/generate-diff.yml<pre><code>jobs:\n  build:\n    ...\n    steps:\n      ...\n    - name: Set Argo CD Custom Values\n      run: |\n        cat &gt; values.yaml &lt;&lt; \"EOF\"\n        # set whatever helm values you want\n        configs:\n          cm:\n            kustomize.buildOptions: --load-restrictor LoadRestrictionsNone --enable-helm\n        EOF\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          -v $(pwd)/pull-request:/target-branch \\\n          -v $(pwd)/values.yaml:/argocd-config/values.yaml \\   \u2b05\ufe0f Mount values.yaml\n          ...\n</code></pre>"},{"location":"getting-started/custom-argo-cd-installation/#argo-cd-config-management-plugins-cmp","title":"Argo CD Config Management Plugins (CMP)","text":"<p>You can install any Argo CD Config Management Plugin that is supported through the Argo CD Helm Chart.</p> <p>Example:</p> <p>This example installs the ArgoCD Lovely plugin using the <code>values.yaml</code> file.</p> .github/workflows/generate-diff.yml<pre><code>jobs:\n  build:\n    ...\n    steps:\n      ...\n    - name: Set Argo CD Custom Values\n      run: |\n        cat &gt; values.yaml &lt;&lt; \"EOF\"\n        repoServer:\n          extraContainers:\n          # ArgoCD Lovely plugin - https://github.com/crumbhole/argocd-lovely-plugin\n            - name: lovely-plugin\n              image: ghcr.io/crumbhole/lovely:1.1.1\n              securityContext:  \n                runAsNonRoot: true\n                runAsUser: 999\n              volumeMounts:\n                  # Import the repo-server's plugin binary\n                - mountPath: /var/run/argocd\n                  name: var-files\n                - mountPath: /home/argocd/cmp-server/plugins\n                  name: plugins\n                - mountPath: /tmp\n                  name: lovely-tmp\n          volumes:\n            - emptyDir: {}\n              name: lovely-tmp\n        EOF\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          -v $(pwd)/pull-request:/target-branch \\\n          -v $(pwd)/values.yaml:/argocd-config/values.yaml \\   \u2b05\ufe0f Mount values.yaml\n          ...\n</code></pre> <p>Questions, issues, or suggestions</p> <p>If you experience issues or have any questions, please open an issue in the repository! \ud83d\ude80</p>"},{"location":"getting-started/github-actions-workflow/","title":"GitHub Actions Workflow","text":""},{"location":"getting-started/github-actions-workflow/#public-repositories","title":"Public repositories","text":"<p>If your repository is public and only uses public Helm charts, you can use the following GitHub Actions workflow to generate a diff between the main branch and the pull request branch. The diff will then be posted as a comment on the pull request.</p> .github/workflows/generate-diff.yml<pre><code>name: Argo CD Diff Preview\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.24\n\n      - name: Post diff as comment\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Instead of using <code>refs/pull/${{ github.event.number }}/merge</code>, you could also use <code>${{ github.head_ref }}</code> or simply specify the branch name manually.  </p> <p>More information about this can be found in this blog post</p>"},{"location":"getting-started/github-actions-workflow/#private-repositories-and-helm-charts","title":"Private repositories and Helm Charts","text":"<p>In the simple code examples above, we do not provide the cluster with any credentials, which only works if the image/Helm Chart registry and the Git repository are public. Since your repository might not be public you need to provide the tool with the necessary read-access credentials for the repository. This can be done by placing the Argo CD repo secrets in folder mounted at <code>/secrets</code>. When the tool starts, it will simply run <code>kubectl apply -f /secrets</code> to apply every resource to the cluster, before starting the rendering process.</p> .github/workflows/generate-diff.yml<pre><code>...\n    - uses: actions/checkout@v4\n      with:\n        ref: main\n        path: main\n\n    - name: Prepare secrets\n      run: |\n        mkdir secrets\n        cat &gt; secrets/secret.yaml &lt;&lt; \"EOF\"\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: private-repo\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repo-creds\n        stringData:\n          url: https://github.com/${{ github.repository }}\n          password: ${{ secrets.GITHUB_TOKEN }}  \u2b05\ufe0f Short-lived GitHub Token\n          username: not-used\n        EOF\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          -v $(pwd)/pull-request:/target-branch \\\n          -v $(pwd)/output:/output \\\n          -v $(pwd)/secrets:/secrets \\           \u2b05\ufe0f Mount the secrets folder\n          -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n          -e REPO=${{ github.repository }} \\\n          dagandersen/argocd-diff-preview:v0.1.24\n</code></pre> <p>If your ArgoCD Applications use SSH to access the private repositories, then you need to configure the secret above using SSH as well.</p> .github/workflows/generate-diff.yml<pre><code>    - name: Prepare secrets\n      run: |\n        mkdir secrets\n        cat &gt; secrets/secret.yaml &lt;&lt; EOF\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: private-repo\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repo-creds\n        stringData:\n          type: git\n          url: git@github.com/${{ github.repository }}\n          sshPrivateKey: |\n        $(echo \"${{ secrets.REPO_ACCESS_SSH_PRIVATE_KEY }}\" | sed 's/^/    /') \u2b05\ufe0f Private SSH key with proper indentation\n        EOF\n</code></pre> <p>If you get this type of error:</p> <pre><code>failed to apply secrets: failed to apply secret secret.yaml: failed to apply manifest: failed to convert new object (namespace/secret-name; /v1, Kind=Secret) to proper version: unable to convert unstructured object to /v1, Kind=Secret: error decoding from json: illegal base64 data at input byte 76 from folder: ./secrets\n</code></pre> <p>it is because <code>base64</code> wraps encoded lines after 76 characters by default:</p> <pre><code>-w, --wrap=COLS\n    Wrap encoded lines after COLS character (default 76). Use 0 to disable line wrapping.\n</code></pre> <p>so you need to use the following alternative:</p> .github/workflows/generate-diff.yml<pre><code>    - name: Prepare secrets\n      run: |\n        mkdir -p secrets\n        SSH_PRIVATE_KEY_B64=$(echo \"${{ secrets.REPO_ACCESS_SSH_PRIVATE_KEY }}\" | base64 -w 0)\n        URL_B64=$(echo \"git@github.com/${{ github.repository }}\" | base64 -w 0)\n        cat &gt; secrets/secret.yaml &lt;&lt;-EOF\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: github-repo-ssh\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repo-creds\n        data:\n          url: \"${URL_B64}\"\n          sshPrivateKey: \"${SSH_PRIVATE_KEY_B64}\"\n        EOF\n</code></pre> <p>If Helm Charts are stored as OCI images in a Docker registry (such as AWS ECR), additional fields must be added to the <code>stringData</code> section as shown below. .github/workflows/generate-diff.yml<pre><code>    - name: Prepare secrets\n      run: |\n        mkdir secrets\n        cat &gt; secrets/secret.yaml &lt;&lt; \"EOF\"\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: private-registry\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repository\n        stringData:\n          name: privateRegistry\n          url: ${{ secrets.REGISTRY_URL }}\n          username: ${{ secrets.REGISTRY_USERNAME }}\n          password: ${{ secrets.REGISTRY_PASSWORD }}\n          type: helm\n          enableOCI: \"true\"\n          forceHttpBasicAuth: \"true\"\n        EOF\n</code></pre></p> <p>For more info, see the Argo CD docs</p>"},{"location":"getting-started/gitlab-cicd/","title":"GitLab CI/CD Workflow","text":""},{"location":"getting-started/gitlab-cicd/#public-repositories","title":"Public repositories","text":"<p>If your repository is public and only uses public Helm charts, you can use the following GitLab CI/CD pipeline to generate a diff between the main branch and the merge request branch. The diff will then be posted as a comment on the merge request.</p> <pre><code>default:\n  tags:\n    - gitlab-org-docker\n\nstages:\n  - diff\n\ndiff:\n  stage: diff\n  image: docker:24.0.5\n  services:\n    - name: docker:24.0.5-dind\n  variables:\n    GITLAB_TOKEN: $GITLAB_PAT\n  before_script:\n    - apk add -q curl jq git\n  script:\n    - |\n      echo \"******** Running analysis ********\"\n      git clone ${CI_REPOSITORY_URL} base-branch --depth 1 -q \n      git clone ${CI_REPOSITORY_URL} target-branch --depth 1 -q -b ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}\n      docker run \\\n        --network host \\\n        -v /var/run/docker.sock:/var/run/docker.sock \\\n        -v $(pwd)/output:/output \\\n        -v $(pwd)/base-branch:/base-branch \\\n        -v $(pwd)/target-branch:/target-branch \\\n        -e TARGET_BRANCH=${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} \\\n        -e REPO=${CI_MERGE_REQUEST_PROJECT_PATH} \\\n        dagandersen/argocd-diff-preview:v0.1.24\n    - |\n      jq --null-input --rawfile msg $(pwd)/output/diff.md '{body: $msg}' &gt; pr_comment.json\n      NOTE_ID=$(curl --silent --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n          \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes\" | \\\n          jq '.[] | select(.body | test(\"Argo CD Diff Preview\")) | .id')\n\n      if [[ -n \"$NOTE_ID\" ]]; then\n          echo \"Deleting existing comment (ID: $NOTE_ID)...\"\n\n          curl --silent --request DELETE --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n              --url \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes/${NOTE_ID}\"\n      fi\n\n      echo \"Adding new comment...\"\n      curl --silent --request POST --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n          --header \"Content-Type: application/json\" \\\n          --url \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes\" \\\n          --data @pr_comment.json &gt; /dev/null\n\n      echo \"Comment added!\"\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n</code></pre>"},{"location":"getting-started/gitlab-cicd/#private-repositories-and-helm-charts","title":"Private repositories and Helm Charts","text":"<p>In the simple code example above, we do not provide the cluster with any credentials, which only works if the image/Helm Chart registry and the Git repository are public. Since your repository might not be public, you need to provide the tool with the necessary read-access credentials for the repository. This can be done by placing the Argo CD repo secrets in a folder mounted at /secrets. When the tool starts, it will simply run <code>kubectl apply -f /secrets</code> to apply every resource to the cluster before starting the rendering process.</p> <pre><code>...\n  before_script:\n    - apk add -q curl jq git\n    - |\n      mkdir secrets\n      cat &gt; secrets/secret.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Secret\n      metadata:\n        name: private-repo\n        namespace: argocd\n        labels:\n          argocd.argoproj.io/secret-type: repo-creds\n      stringData:\n        url: https://gitlab.com/${CI_PROJECT_PATH}\n        password: ${GITLAB_TOKEN}  \u2b05\ufe0f Short-lived GitLab Token\n        username: token\n      EOF\n\n  script:\n    - |\n      echo \"******** Running analysis ********\"\n      git clone ${CI_REPOSITORY_URL} base-branch --depth 1 -q \n      git clone ${CI_REPOSITORY_URL} target-branch --depth 1 -q -b ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}\n      docker run \\\n        --network host \\\n        -v /var/run/docker.sock:/var/run/docker.sock \\\n        -v $(pwd)/output:/output \\\n        -v $(pwd)/base-branch:/base-branch \\\n        -v $(pwd)/target-branch:/target-branch \\\n        -v $(pwd)/secrets:/secrets \\           \u2b05\ufe0f Mount the secrets folder\n        -e TARGET_BRANCH=${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} \\\n        -e REPO=${CI_MERGE_REQUEST_PROJECT_PATH} \\\n        dagandersen/argocd-diff-preview:v0.1.24\n</code></pre> <p>For more info, see the Argo CD docs</p>"},{"location":"getting-started/installation/","title":"Running it locally","text":"DockerBinary"},{"location":"getting-started/installation/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Install: Docker</li> </ul>"},{"location":"getting-started/installation/#usage","title":"Usage","text":"<p>You need to pull down the two branches you want to compare. The first branch will be cloned into the <code>base-branch</code> folder, and the other branch will be cloned into the <code>target-branch</code> folder.</p> <pre><code>git clone https://github.com/&lt;owner&gt;/&lt;repo&gt; base-branch --depth 1 -q -b &lt;branch-a&gt;\n\ngit clone https://github.com/&lt;owner&gt;/&lt;repo&gt; target-branch --depth 1 -q -b &lt;branch-b&gt;\n</code></pre> <p>Then you can run the tool using the following command:</p> <pre><code>docker run \\\n  --network host \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v $(pwd)/output:/output \\\n  -v $(pwd)/base-branch:/base-branch \\\n  -v $(pwd)/target-branch:/target-branch \\\n  -e TARGET_BRANCH=&lt;branch-a&gt; \\\n  -e BASE_BRANCH=&lt;branch-b&gt; \\\n  -e REPO=&lt;owner&gt;/&lt;repo&gt;  \\\n  dagandersen/argocd-diff-preview:v0.1.24\n</code></pre> <p>If base-branch(<code>BASE_BRANCH</code>) is not specified it will default to <code>main</code>.</p>"},{"location":"getting-started/installation/#pre-requisites_1","title":"Pre-requisites","text":"<p>Install:</p> <ul> <li>Git</li> <li>Docker</li> <li>kubectl</li> <li>kind OR minikube</li> <li>Argo CD CLI</li> </ul>"},{"location":"getting-started/installation/#find-the-correct-binary-for-your-operating-system","title":"Find the correct binary for your operating system","text":"<p>Check the releases and find the correct binary for your operating system.</p> <p>Example for downloading and running on macOS:</p> <pre><code>curl -LJO https://github.com/dag-andersen/argocd-diff-preview/releases/download/v0.1.24/argocd-diff-preview-Darwin-x86_64.tar.gz\ntar -xvf argocd-diff-preview-Darwin-x86_64.tar.gz\nsudo mv argocd-diff-preview /usr/local/bin\nargocd-diff-preview --help\n</code></pre>"},{"location":"getting-started/installation/#usage_1","title":"Usage","text":"<p>You need to pull down the two branches you want to compare. The first branch will be cloned into the <code>base-branch</code> folder, and the other branch will be cloned into the <code>target-branch</code> folder.</p> <pre><code>git clone https://github.com/&lt;owner&gt;/&lt;repo&gt; base-branch --depth 1 -q -b &lt;branch-a&gt;\n\ngit clone https://github.com/&lt;owner&gt;/&lt;repo&gt; target-branch --depth 1 -q -b &lt;branch-b&gt;\n</code></pre>"},{"location":"getting-started/installation/#run-the-binary","title":"Run the binary","text":"<pre><code>argocd-diff-preview \\\n  --repo &lt;owner&gt;/&lt;repo-name&gt; \\\n  --base-branch &lt;branch-a&gt; \\\n  --target-branch &lt;branch-b&gt;\n</code></pre> <p>If base-branch is not specified it will default to <code>main</code>.</p>"},{"location":"getting-started/self-hosted-gh-runner/","title":"Self-Hosted GitHub Actions Runners on Kubernetes","text":"<p>Running <code>argocd-diff-preview</code> with self-hosted GitHub Actions runners inside your Kubernetes cluster offers significant advantages over GitHub-hosted runners. Most notably, you can directly access Argo CD's cluster and GitHub/GitLab credentials from the host cluster, eliminating the need to store credentials in your CI/CD pipeline.</p> <p>This guide covers two main approaches for using self-hosted runners with <code>argocd-diff-preview</code>.</p>"},{"location":"getting-started/self-hosted-gh-runner/#approach-1-ephemeral-cluster-inside-runner-pod","title":"Approach 1: Ephemeral Cluster inside Runner Pod","text":"<p>This approach creates a temporary cluster for each diff preview run while reusing credentials from your existing Argo CD installation. It provides isolation for the diff preview while not storing the credentials in your CI/CD pipeline.</p> <p></p>"},{"location":"getting-started/self-hosted-gh-runner/#how-it-works","title":"How It Works","text":"<p>When your self-hosted runner pod runs inside the same cluster as Argo CD:</p> <ol> <li>The runner can access Argo CD secrets using <code>kubectl get secrets -n argocd</code></li> <li>These secrets are extracted and cleaned of cluster-specific metadata</li> <li>The secrets are mounted into the <code>argocd-diff-preview</code> container</li> <li>An ephemeral cluster is created with these credentials pre-configured</li> <li>The diff preview runs with full access to your Git repositories and Helm registries</li> </ol>"},{"location":"getting-started/self-hosted-gh-runner/#benefits","title":"Benefits","text":"<ul> <li>Secure credential access - No need to expose secrets to GitHub. The credentials are read directly from the host cluster and they are always in sync</li> <li>Isolated execution - Each run creates a fresh, ephemeral cluster. Never interacts with your \"real\" Argo CD instance.</li> <li>Easy cleanup - Ephemeral clusters are automatically removed.</li> </ul>"},{"location":"getting-started/self-hosted-gh-runner/#example-workflow","title":"Example Workflow","text":"<p>This example is meant for inspiration. You can structure it in many different ways.</p> .github/workflows/generate-diff.yml<pre><code>name: Diff Preview\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  diff-preview:\n    name: Diff Preview\n    runs-on: your-arc-runner  # Replace with your self-hosted runner label\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n          fetch-depth: 0\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - uses: azure/setup-kubectl@v4\n        id: install\n\n      # Extract secrets from the host cluster and prepare them for the ephemeral cluster\n      - name: Get secrets from host cluster\n        run: |\n          mkdir -p secrets\n\n          # Get all Argo CD secrets from the host cluster\n          kubectl get secrets -n argocd -o json -l argocd.argoproj.io/secret-type &gt; argocd-secrets.json\n\n          # Clean up cluster-specific metadata that shouldn't be transferred\n          jq '{\n            apiVersion: \"v1\",\n            kind: \"List\",\n            items: [\n              .items[] \n              | del(\n                  .metadata.annotations,\n                  .metadata.creationTimestamp,\n                  .metadata.ownerReferences,\n                  .metadata.resourceVersion,\n                  .metadata.selfLink,\n                  .metadata.uid,\n                  .metadata.managedFields\n                ) \n              | .metadata.namespace = \"argocd\"\n            ]\n          }' argocd-secrets.json &gt; processed-secrets.json\n\n          # Split into individual files\n          counter=1\n          jq -c '.items[]' processed-secrets.json | while IFS= read -r line; do\n            if [ -n \"$line\" ]; then\n              echo \"$line\" | jq '.' &gt; \"secrets/manifest-$(printf \"%03d\" $counter).json\"\n              counter=$((counter + 1))\n            fi\n          done\n\n          # Clean up temporary files\n          rm -f argocd-secrets.json processed-secrets.json\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/secrets:/secrets \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.24\n\n      - name: Post diff as comment\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"getting-started/self-hosted-gh-runner/#approach-2-connecting-to-a-pre-configured-argo-cd","title":"Approach 2: Connecting to a pre-configured Argo CD","text":"<p>For enhanced security and performance, you can skip the ephemeral cluster creation entirely and use a pre-configured Argo CD instance directly. This approach is covered in detail in the Connecting the self-hosted runner to Argo CD on the host cluster guide.</p>"},{"location":"getting-started/self-hosted-gh-runner/#handling-cidr-collisions","title":"Handling CIDR Collisions","text":"<p>When using Action Runner Controller (ARC) to self-host your GitHub Actions runners, the ephemeral kind cluster created by <code>argocd-diff-preview</code> may have CIDR ranges that conflict with your host cluster's network configuration. These overlapping ranges can cause networking issues during the diff preview process.</p>"},{"location":"getting-started/self-hosted-gh-runner/#default-cidr-ranges","title":"Default CIDR Ranges","text":"<p>The kind cluster uses these default CIDR ranges:</p> Type CIDR Range Service 10.96.0.0/16 Pod 10.244.0.0/16 <p>If these ranges overlap with your host cluster's CIDRs, you'll need to configure custom ranges for the ephemeral cluster.</p>"},{"location":"getting-started/self-hosted-gh-runner/#configuring-custom-cidrs","title":"Configuring Custom CIDRs","text":"<p>Step 1: Create a kind configuration file</p> <p>Create a file in your repository (e.g., <code>hack/kind.yaml</code>) with non-overlapping CIDR ranges:</p> hack/kind.yaml<pre><code>kind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnetworking:\n  serviceSubnet: \"10.80.0.0/16\"\n  podSubnet: \"10.128.0.0/16\"\n</code></pre> <p>Step 2: Pass the configuration to <code>argocd-diff-preview</code></p> <p>Add the <code>--kind-options</code> flag to your workflow to use the custom configuration:</p> .github/workflows/generate-diff.yml<pre><code>      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.24 \\\n            --kind-options '--config /base-branch/hack/kind.yaml'\n</code></pre>"},{"location":"reusing-clusters/connecting/","title":"Connecting to a cluster with Argo CD pre-installed","text":"<p>Instead of spinning up an ephemeral cluster for each diff preview, you can connect to a cluster with Argo CD already installed. This saves approximately <code>60</code>\u2013<code>90</code> seconds per run.</p> <p>Important: We highly recommend not using your production Argo CD instance for rendering manifests. Instead, install a dedicated Argo CD instance for diff previews.</p> <p>The Argo CD server does not need to be exposed to the internet, since <code>argocd-diff-preview</code> connects via a KubeConfig file (or service account).</p> <p>To use this feature, mount a valid KubeConfig with access to the cluster and provide these options:</p> <pre><code>--create-cluster false --argocd-namespace &lt;namespace&gt;\n</code></pre> <p>This will skip cluster creation and connect to Argo CD via port-forwarding in the specified namespace.</p>"},{"location":"reusing-clusters/connecting/#requirements","title":"Requirements","text":"<ul> <li>The <code>default</code> Argo CD project must exist.</li> <li>The required secrets for authentication have already been added to the cluster.</li> </ul>"},{"location":"reusing-clusters/connecting/#example-demo","title":"Example Demo","text":""},{"location":"reusing-clusters/connecting/#step-1-create-cluster-skip-if-you-already-have-a-cluster-with-argo-cd-installed","title":"Step 1: Create cluster (skip if you already have a cluster with Argo CD installed)","text":"<pre><code>kind create cluster\nhelm repo add argo https://argoproj.github.io/argo-helm\nhelm install argo-cd argo/argo-cd --version 8.0.3 --create-namespace --namespace argocd-diff-preview\n</code></pre> <pre><code># Wait for Argo CD to be ready\nkubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd-diff-preview\n</code></pre>"},{"location":"reusing-clusters/connecting/#step-2-clone-the-base-and-target-branches","title":"Step 2: Clone the base and target branches","text":"<pre><code># Clone the base branch into a subfolder called `base-branch`\ngit clone https://github.com/dag-andersen/argocd-diff-preview base-branch --depth 1 -q \n\n# Clone the target branch into a subfolder called `target-branch`\ngit clone https://github.com/dag-andersen/argocd-diff-preview target-branch --depth 1 -q -b helm-example-3\n</code></pre>"},{"location":"reusing-clusters/connecting/#step-3-run-the-tool","title":"Step 3: Run the tool","text":"<p>Make sure you: - Mount the KubeConfig into the container (<code>-v ~/.kube:/root/.kube</code>) - Disable cluster creation (<code>--create-cluster=false</code>) - Specify the Argo CD namespace (<code>--argocd-namespace=&lt;ns&gt;</code>)</p> <pre><code>docker run \\\n  --network host \\\n  -v ~/.kube:/root/.kube \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v $(pwd)/output:/output \\\n  -v $(pwd)/base-branch:/base-branch \\\n  -v $(pwd)/target-branch:/target-branch \\\n  -e TARGET_BRANCH=helm-example-3 \\\n  -e REPO=dag-andersen/argocd-diff-preview \\\n  dagandersen/argocd-diff-preview:v0.1.24 \\\n  --argocd-namespace=argocd-diff-preview \\\n  --create-cluster=false\n</code></pre> <p>And then the output will look something like this:</p> <pre><code>\u2728 Running with:\n\u2728 - reusing cluster with Argo CD pre-installed\n\u2728 - base-branch: main\n\u2728 - target-branch: helm-example-3\n\u2728 - output-folder: ./output\n\u2728 - argocd-namespace: argocd-diff-preview\n\u2728 - repo: dag-andersen/argocd-diff-preview\n\u2728 - timeout: 180 seconds\n\ud83d\udd11 Unique ID for this run: 60993\n\ud83e\udd16 Fetching all files for branch (branch: main)\n\ud83e\udd16 Found 52 files in dir base-branch (branch: main)\n...\n\ud83e\udd16 Fetching all files for branch (branch: helm-example-3)\n\ud83e\udd16 Found 52 files in dir target-branch (branch: helm-example-3)\n...\n\ud83e\udd91 Logging in to Argo CD through CLI...\n\ud83e\udd91 Logged in to Argo CD successfully\n\ud83e\udd16 Converting ApplicationSets to Applications in both branches\n...\n\ud83e\udd16 Patching 19 Applications (branch: main)\n\ud83e\udd16 Patching 19 Applications (branch: helm-example-3)\n\ud83e\udd16 Rendered 11 out of 38 applications (timeout in 175 seconds)\n\ud83e\uddfc Waiting for all application deletions to complete...\n\ud83e\uddfc All application deletions completed\n\ud83e\udd16 Got all resources from 19 applications from base-branch and got 19 from target-branch in 7s\n\ud83d\udd2e Generating diff between main and helm-example-3\n\ud83d\ude4f Please check the ./output/diff.md file for differences\n\u2728 Total execution time: 10s\n</code></pre>"},{"location":"reusing-clusters/connecting/#authenticate-with-cloud-providers","title":"Authenticate with Cloud Providers","text":"<p>If you're connecting to a cluster on a cloud provider, you often use a plugin or ExecConfig to authenticate (for example, <code>kubelogin</code> for Azure AKS or <code>aws eks get-token</code> for AWS EKS).</p> <p>You can check this by running <code>kubectl config view --minify -o jsonpath='{.users[*].user}'</code> and looking for the <code>command</code> field.</p> <p>These plugins/binaries are not available inside the Docker image, so you'll need to run <code>argocd-diff-preview</code> as a standalone binary.</p> <p>You can find installation instructions in the docs.</p>"},{"location":"reusing-clusters/lockdown-mode/","title":"Lockdown Mode (Namespace-Scoped Argo CD)","text":"<p>By default, Argo CD is installed with cluster-wide permissions, meaning it can read and manage resources across all namespaces. However, some organizations require a more restricted setup where Argo CD only has permissions within a single namespace. This is often referred to as \"namespace-scoped\" or \"lockdown mode\".</p> <p>This page explains how to use <code>argocd-diff-preview</code> with a namespace-scoped Argo CD installation.</p>"},{"location":"reusing-clusters/lockdown-mode/#why-lockdown-mode","title":"Why Lockdown Mode?","text":"<p>When using a pre-installed Argo CD instance for diff previews, you may want to restrict its permissions for security reasons:</p> <ul> <li>Prevent secret access: A cluster-scoped Argo CD can read secrets from any namespace. With lockdown mode, Argo CD can only access resources in its own namespace.</li> <li>Isolation: The diff preview Argo CD instance is completely isolated from your production workloads.</li> </ul>"},{"location":"reusing-clusters/lockdown-mode/#how-it-works","title":"How It Works","text":"<p>In lockdown mode, <code>argocd-diff-preview</code> uses the Argo CD API directly to retrieve manifests, rather than relying on the application controller's sync status. This allows the tool to work even when Argo CD doesn't have permission to check the destination namespaces.</p>"},{"location":"reusing-clusters/lockdown-mode/#requirements","title":"Requirements","text":"<ul> <li>Argo CD installed with <code>createClusterRoles: false</code> (namespace-scoped)</li> <li>The <code>--use-argocd-api=\"true\"</code> flag enabled when running <code>argocd-diff-preview</code></li> </ul>"},{"location":"reusing-clusters/lockdown-mode/#installing-namespace-scoped-argo-cd","title":"Installing Namespace-Scoped Argo CD","text":"<p>Here's an example Helm values file for installing Argo CD with namespace-scoped permissions:</p> values.yaml<pre><code>nameOverride: argocd-diff-preview\nnamespaceOverride: \"argocd-diff-preview\"\ncreateClusterRoles: false # The important part!\ncrds:\n  install: false # Only install CRDs if you don't have them already installed\nnotifications:\n  enabled: false\ndex:\n  enabled: false\napplicationSet:\n  replicas: 0\ncontroller:\n  roleRules:\n    - apiGroups:\n        - \"*\"\n      resources:\n        - \"*\"\n      verbs:\n        - get\n        - list\n        - watch\n    - apiGroups:\n        - argoproj.io\n      resources:\n        - applications\n        - applications/status\n      verbs:\n        - get\n        - list\n        - watch\n        - update\n        - patch\n</code></pre> <p>Install with:</p> <pre><code>helm repo add argo https://argoproj.github.io/argo-helm\nhelm install argo-cd argo/argo-cd \\\n  --create-namespace \\\n  --namespace argocd-diff-preview \\\n  -f values.yaml\n</code></pre>"},{"location":"reusing-clusters/lockdown-mode/#running-argocd-diff-preview-in-lockdown-mode","title":"Running <code>argocd-diff-preview</code> in Lockdown Mode","text":"<p>To use lockdown mode, add the <code>--use-argocd-api=\"true\"</code> flag:</p> .github/workflows/generate-diff.yml<pre><code>docker run \\\n  --network host \\\n  -v ~/.kube:/root/.kube \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v $(pwd)/output:/output \\\n  -v $(pwd)/base-branch:/base-branch \\\n  -v $(pwd)/target-branch:/target-branch \\\n  -e TARGET_BRANCH=my-feature-branch \\\n  -e REPO=my-org/my-repo \\\n  dagandersen/argocd-diff-preview:v0.1.24 \\\n  --argocd-namespace=argocd-diff-preview \\\n  --create-cluster=false \\\n  --use-argocd-api=\"true\"\n</code></pre>"},{"location":"reusing-clusters/lockdown-mode/#limitations","title":"Limitations","text":"<ul> <li>Applications will show as \"Unknown\" status in the Argo CD UI since the application controller cannot access the destination namespaces</li> <li>Some ApplicationSet generators that require cluster-wide access may not work</li> </ul>"},{"location":"reusing-clusters/lockdown-mode/#related-issues","title":"Related Issues","text":"<ul> <li>#250 - Limit ArgoCD to a single namespace</li> </ul>"},{"location":"reusing-clusters/openshift/","title":"Setup a dedicated ArgoCD instance in Openshift","text":"<p>Running <code>argocd-diff-preview</code> against a cluster that has Argo CD pre-installed combines maximum performance with enhanced security. This approach eliminates both cluster creation overhead and the need to store cluster credentials in your CI/CD pipeline. </p> <p>Utilizing the Openshift GitOps operator for managing the pre-installed ArgoCD instance comes with low overhead of managing another ArgoCD instance. It is included in the Operator upgrade process and is in line with the ArgoCD instances in the cluster used to deploy applications. In this setup, there is also no need to run <code>argocd-diff-preview</code> as DinD (Docker in Docker) which further increases security. In addition, if there are network settings in place in order to access private repositories outside of the Openshift cluster, this will work right away with this setup. If the main ArgoCD instance is also used to deploy its own configuration (e.g. ssh-known-hosts, tls certs, etc.) in a GitOps way, the instance for <code>argocd-diff-preview</code> can be configured in the same way for faster integration.</p> <p>Imagine something like this:</p> <p></p>"},{"location":"reusing-clusters/openshift/#how-it-works","title":"How it works","text":"<ol> <li>Configure dedicated ArgoCD instance managed by Openshift GitOps Operator in your cluster in the namespace <code>argocd-diff-preview</code></li> <li>Setup a runner in the cluster and connect it to your CI system</li> <li>The runner uses a service account to connect to the host cluster and access the Argo CD instance</li> <li>The tool runs exactly as before, but without any credential management complexity and without creating an ephemeral cluster</li> </ol>"},{"location":"reusing-clusters/openshift/#setup-guide","title":"Setup Guide","text":""},{"location":"reusing-clusters/openshift/#1-create-a-dedicated-argocd-instance-for-rendering-previews","title":"1. Create a dedicated ArgoCD instance for rendering previews","text":"<ol> <li>Open the Administrator view in the Openshift UI</li> <li>Go to Operators -&gt; Installed Operators -&gt; Red Hat OpenShift GitOps</li> <li>In the ArgoCD tab click Create ArgoCD and configure via YAML view</li> <li>Provide <code>argocd</code> as the new name of the ArgoCD instance in the field <code>metadata.name</code> (important as argocd-diff-preview expects that name) </li> <li>Provide the target namespace in <code>metadata.namespace</code> (e.g.<code>argocd-diff-preview</code>) in the yaml manifest.</li> <li>Click Create</li> </ol> <p>By default, this action will create a namespace-scoped ArgoCD instance.</p>"},{"location":"reusing-clusters/openshift/#2-make-the-new-argocd-instance-cluster-scoped","title":"2. Make the new ArgoCD instance cluster-scoped","text":"<p>To provide ArgoCD with enough permissions to read the live state of all namespaces it needs to be cluster-scoped.</p> <ol> <li>Open the Administrator view in the Openshift UI</li> <li>Go to Operators -&gt; Installed Operators -&gt; Red Hat OpenShift GitOps</li> <li> <p>In the Subscription tab click Action -&gt; Edit Subscription</p> <p>(Alternative is to edit the subcription over command line like so: <code>oc edit subscription  openshift-gitops-operator -n openshift-operators</code>)</p> </li> <li> <p>Add the following entry in <code>spec.config.env</code> (this entry may not exist yet and needs to be added). The value should contain a list of your current GitOps cluster scoped instance namespaces including the new one:</p> <p><pre><code>...\nkind: Subscription\n...\nspec:\n  ...\n  config:\n    env:\n    - name: ARGOCD_CLUSTER_CONFIG_NAMESPACES\n      value: openshift-gitops,argocd-diff-preview\n  ...\n</code></pre> 5. Click Save</p> </li> </ol> <p>After this change, the Openshift GitOps controller will create a clusterrole and clusterrolebinding for the new ArgoCD instance that allows ArgoCD to read the live state within the cluster. </p> <p>To check the permissions you can investigate the newly created clusterrole and clusterrolebinding:</p> <pre><code>oc get clusterrolebindings argocd-argocd-diff-preview-argocd-application-controller -o yaml\noc get clusterroles argocd-argocd-diff-preview-argocd-application-controller -o yaml\n</code></pre> <p>An actual sync of an ArgCD application (that won't be triggered by <code>argocd-diff-preview</code> anyway) within this new ArgoCD instance would still fail, as the target namespaces are missing the label <code>argocd.argoproj.io/managed-by=argocd-diff-preview</code>.</p> <p>Background information</p> <p><code>argocd-diff-preview</code> will call <code>argocd app manifest</code> to retrieve the rendered manifests for comparison. For this to work, the ArgoCD application has to be created without errors. Without additional permissions, one will get the following example error for applications that have a target namespace different then the one of the namespace-scoped ArgoCD instance (which will be the case for all diffs):</p> <p><code>Failed to load live state: namespace \"default\" for Service \"kustomize-guestbook-ui\" is not managed</code></p> <p>There is already a feature reuqest opended to make <code>argocd-diff-preview</code> work with a namespace-scoped ArgoCD instance.</p>"},{"location":"reusing-clusters/openshift/#3-configure-argocd-for-private-repositories-optional","title":"3. Configure ArgoCD for private repositories (optional)","text":"<p>To reduce credential handling and private repository configuration in the CI pipeline the configuration can be done once in the dedicated ArgoCD instance. One can add repository credential templates or configure ssh-known-hosts ConfigMap for safe cloning via ssh. This offloads these tasks from the CI run that actually runs <code>argocd-diff-preview</code> which allows for a more lightweight CI integration accross different repositories.</p>"},{"location":"reusing-clusters/openshift/#4-configure-rbac","title":"4. Configure RBAC","text":"<pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: argocd-diff-preview-access\n  namespace: argocd-diff-preview\n---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: argocd-diff-preview-access\n  namespace: argocd-diff-preview\nrules:\n  - apiGroups: [\"*\"]\n    resources: [\"*\"]\n    verbs: [\"*\"]\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: argocd-diff-preview-access\n  namespace: argocd-diff-preview\nsubjects:\n  - kind: ServiceAccount\n    name: argocd-diff-preview-access\n    namespace: argocd-diff-preview\nroleRef:\n  kind: Role\n  name: argocd-diff-preview-access\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"reusing-clusters/openshift/#5-create-a-service-account-token","title":"5. Create a service account token","text":"<p>With the following command a service account token is created in Openshift.</p> <p><code>oc create token argocd-diff-preview-access --namespace argocd-diff-preview</code></p> <p>It can be used to login to the cluster in a CI job and create the kube config file for <code>argocd-diff-preview</code> to be able to login. In the CI example that is presented at the end this token will be saved in the variable <code>$ARGOCD_DIFF_PREVIEW_OPENSHIFT_SA_TOKEN</code>.</p>"},{"location":"reusing-clusters/openshift/#6-create-an-image-for-a-self-hosted-ci-runner","title":"6. Create an image for a self-hosted CI runner","text":"<p>To use <code>argocd-diff-preview</code> as a binary and have all tools available to update a Gitlab Merge Request, an image for a Gitlab runner can be prepared.</p> <p>Example Dockerfile <code>argocd-diff-preview-runner</code> based on a Red Hat UBI image:</p> Dockerfile<pre><code>FROM registry.access.redhat.com/ubi10-minimal:latest\n\nRUN microdnf install -y curl git tar unzip &amp;&amp; \\\n    rm -rf /var/cache/yum/*\n\n# argocd CLI\n# dependency of argocd-diff-preview\nRUN curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64 &amp;&amp; \\\n    install -m 555 argocd-linux-amd64 /usr/local/bin/argocd &amp;&amp; \\\n    rm argocd-linux-amd64 &amp;&amp; \\\n    argocd version || true\n\n# argocd-diff-preview CLI\nRUN curl -LJO https://github.com/dag-andersen/argocd-diff-preview/releases/download/v0.1.24/argocd-diff-preview-Linux-x86_64.tar.gz &amp;&amp; \\\n    tar -xvf argocd-diff-preview-Linux-x86_64.tar.gz &amp;&amp; \\\n    mv argocd-diff-preview /usr/local/bin &amp;&amp; \\\n    argocd-diff-preview --version\n\n# kubectl CLI\n# dependency of argocd-diff-preview, utilized by go k8s-client\nRUN curl -LO https://dl.k8s.io/release/v1.34.0/bin/linux/amd64/kubectl &amp;&amp; \\\n    install -m 555 kubectl /usr/local/bin/kubectl &amp;&amp; \\\n    rm -f kubectl\n\n# oc CLI\n# utilized by runner to login to openshift with the argocd-diff-preview-access service account\n# e.g. oc login --server \"$OPENSHIFT_SERVER\" -token=\"$ARGOCD_DIFF_PREVIEW_OPENSHIFT_SA_TOKEN\"\nRUN curl -L -o /tmp/oc.tar.gz https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable/openshift-client-linux.tar.gz &amp;&amp; \\\n    tar -xzvf /tmp/oc.tar.gz -C /usr/local/bin oc &amp;&amp; \\\n    chmod +x /usr/local/bin/oc &amp;&amp; \\\n    rm -f /tmp/oc.tar.gz\n</code></pre>"},{"location":"reusing-clusters/openshift/#usage","title":"Usage","text":""},{"location":"reusing-clusters/openshift/#7-create-a-gitlab-pipeline-and-run-argocd-diff-preview-as-binary","title":"7. Create a Gitlab pipeline and run <code>argocd-diff-preview</code> as binary","text":"<p>The following example utilizes a Gitlab runner in the same cluster where the dedicated ArgoCD instance is setup. The key parts are:</p> <ul> <li>logging into the Openshift cluster as the ServiceAccount <code>argocd-diff-preview-access</code></li> <li>running <code>argocd-diff-preview</code> as binary with the options <code>--argocd-namespace=argocd-diff-preview</code> and <code>--create-cluster=false</code> to use the pre-installed ArgoCD</li> <li>Update the Gitlab Merge Request with the diff using a Gitlab token that has appropriate permissions</li> </ul> <pre><code>default:\n  tags:\n    - openshift-gitlab-runner\n\nstages:\n  - diff\n\ndiff:\n  image: &lt;your-registry&gt;/argocd-diff-preview-runner\n  variables:\n    OPENSHIFT_SERVER: \"&lt;your-openshift-server-url&gt;\"\n    GITLAB_TOKEN: $GITLAB_PAT\n  script:\n    - echo \"******** Running analysis ********\"\n    - git clone ${CI_REPOSITORY_URL} base-branch --depth 1 -q \n    - git clone ${CI_REPOSITORY_URL} target-branch --depth 1 -q -b ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}\n    # initiate kubeconfig creation that argocd-diff-preview can use\n    - oc login --server \"$OPENSHIFT_SERVER\" --token=\"$ARGOCD_DIFF_PREVIEW_OPENSHIFT_SA_TOKEN\"\n    - |\n      argocd-diff-preview \\\n        --repo ${CI_MERGE_REQUEST_PROJECT_PATH} \\\n        --base-branch main \\\n        --target-branch ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} \\\n        --argocd-namespace=argocd-diff-preview \\\n        --create-cluster=false\n    - |\n      jq --null-input --rawfile msg $(pwd)/output/diff.md '{body: $msg}' &gt; pr_comment.json\n      NOTE_ID=$(curl --silent --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n          \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes\" | \\\n          jq '.[] | select(.body | test(\"Argo CD Diff Preview\")) | .id')\n\n      if [[ -n \"$NOTE_ID\" ]]; then\n          echo \"Deleting existing comment (ID: $NOTE_ID)...\"\n\n          curl --silent --request DELETE --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n              --url \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes/${NOTE_ID}\"\n      fi\n\n      echo \"Adding new comment...\"\n      curl --silent --request POST --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n          --header \"Content-Type: application/json\" \\\n          --url \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes\" \\\n          --data @pr_comment.json &gt; /dev/null\n\n      echo \"Comment added!\"\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n</code></pre>"},{"location":"reusing-clusters/self-hosted-gh-runner/","title":"Connecting the self-hosted runner to Argo CD on the host cluster","text":"<p>Running <code>argocd-diff-preview</code> on a self-hosted runner on a cluster that has Argo CD pre-installed combines maximum performance with enhanced security. This approach eliminates both cluster creation overhead and the need to store cluster credentials in your CI/CD pipeline.</p> <p>Instead of creating a temporary cluster for each diff preview, your self-hosted GitHub Actions runner connects directly to a dedicated Argo CD instance running in the same cluster. This offers fast execution (no cluster creation overhead) and enhanced security (no credential sharing).</p> <p>Imagine something like this:</p> <p></p>"},{"location":"reusing-clusters/self-hosted-gh-runner/#how-it-works","title":"How It Works","text":"<ol> <li>Install Action Runner Controller (ARC) in your cluster alongside the dedicated Argo CD instance in the namespace <code>argocd-diff-preview</code></li> <li>The runner uses a service account to connect to the host cluster and access the Argo CD instance</li> <li>The tool runs exactly as before, but without any credential management complexity and without creating an ephemeral cluster</li> </ol>"},{"location":"reusing-clusters/self-hosted-gh-runner/#setup-guide","title":"Setup Guide","text":"<p>This step-by-step guide walks you through setting up self-hosted runners with an existing Argo CD cluster.</p>"},{"location":"reusing-clusters/self-hosted-gh-runner/#step-1-prepare-your-cluster","title":"Step 1: Prepare Your Cluster","text":"<p>If you already have a cluster with Argo CD installed, skip to Step 2. Otherwise, create a dedicated cluster:</p> <pre><code># Create a kind cluster\nkind create cluster --name argocd-diff-preview\n\n# Add Argo CD Helm repository\nhelm repo add argo https://argoproj.github.io/argo-helm\nhelm repo update\n\n# Install Argo CD\nhelm install argo-cd argo/argo-cd \\\n  --version 8.0.3 \\\n  --namespace argocd-diff-preview \\\n  --create-namespace\n</code></pre>"},{"location":"reusing-clusters/self-hosted-gh-runner/#step-2-install-action-runner-controller-arc","title":"Step 2: Install Action Runner Controller (ARC)","text":"<p>ARC Documentation</p> <p>This guide may become outdated. For the latest ARC installation instructions, see the official GitHub documentation.</p> <p>Install the ARC controller and runner scale set to enable self-hosted GitHub Actions runners:</p> <p>Install the controller:</p> <pre><code># Add the ARC Helm repository\nhelm repo add arc-systems https://actions-runner-controller.github.io/arc\nhelm repo update\n\n# Install the controller\nhelm install arc arc-systems/gha-runner-scale-set-controller \\\n  --version 0.12.1 \\\n  --namespace arc-systems \\\n  --create-namespace\n</code></pre> <p>Create authentication secret:</p> <p>First, create a GitHub Personal Access Token (PAT) with <code>repo</code> scope, then create the secret:</p> <pre><code>kubectl create secret generic arc-runner-auth \\\n  --namespace arc-runners \\\n  --from-literal=github_token=\"your-github-token-here\"\n</code></pre> <p>Or using a YAML file:</p> arc-runner-auth.yaml<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: arc-runner-auth\n  namespace: arc-runners\ntype: Opaque\nstringData:\n  github_token: \"your-github-token-here\"\n</code></pre> <p>Install the runner scale set:</p> <p>Create a configuration file for the runner scale set:</p> arc-runner-set.yaml<pre><code>githubConfigUrl: \"https://github.com/&lt;org&gt;/&lt;repo&gt;\"  # Replace with your repo\ngithubConfigSecret: arc-runner-auth\n\ncontrollerServiceAccount:\n  name: arc-gha-rs-controller\n  namespace: arc-systems\n\nrunnerScaleSetName: argocd-diff-runner  # This name will be used in workflows\n\ntemplate:\n  spec:\n    serviceAccountName: arc-runner\n    automountServiceAccountToken: true\n</code></pre> <p>Install the runner scale set:</p> <pre><code># Add the runner scale set Helm repository\nhelm repo add arc-runners https://actions-runner-controller.github.io/arc\n\n# Install the runner scale set\nhelm install arc-runner-set arc-runners/gha-runner-scale-set \\\n  --version 0.12.1 \\\n  --namespace arc-runners \\\n  --create-namespace \\\n  -f arc-runner-set.yaml\n</code></pre>"},{"location":"reusing-clusters/self-hosted-gh-runner/#step-3-configure-rbac","title":"Step 3: Configure RBAC","text":"<p>The runner service account needs permissions to access Argo CD resources (in the namespace <code>argocd-diff-preview</code>). Create the following RBAC configuration:</p> arc-runner-rbac.yaml<pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: arc-runner\n  namespace: arc-runners\n---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: arc-runner-diff-preview\n  namespace: argocd-diff-preview\nrules:\n  - apiGroups: [\"*\"]\n    resources: [\"*\"]\n    verbs: [\"*\"]\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: arc-runner-diff-preview\n  namespace: argocd-diff-preview\nsubjects:\n  - kind: ServiceAccount\n    name: arc-runner\n    namespace: arc-runners\nroleRef:\n  kind: Role\n  name: arc-runner-diff-preview\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>Apply the RBAC configuration:</p> <pre><code>kubectl apply -f arc-runner-rbac.yaml\n</code></pre>"},{"location":"reusing-clusters/self-hosted-gh-runner/#usage","title":"Usage","text":""},{"location":"reusing-clusters/self-hosted-gh-runner/#step-4-create-github-actions-workflow","title":"Step 4: Create GitHub Actions Workflow","text":"<p>Now create a workflow that uses your self-hosted runner. There are two approaches: using the binary directly or using Docker.</p>"},{"location":"reusing-clusters/self-hosted-gh-runner/#option-a-using-the-binary-recommended","title":"Option A: Using the Binary (Recommended)","text":"<p>This approach installs the <code>argocd-diff-preview</code> binary directly on the runner:</p> .github/workflows/diff-preview.yml<pre><code>name: Diff Preview\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  diff-preview:\n    name: Diff Preview\n    runs-on: argocd-diff-runner  # Use your runner scale set name\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: target-branch\n          fetch-depth: 0\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: base-branch\n\n      - name: Setup kubectl\n        uses: azure/setup-kubectl@v4\n\n      - name: Install Argo CD CLI\n        run: |\n          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64\n          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd\n          rm argocd-linux-amd64\n          argocd version\n\n      - name: Install argocd-diff-preview\n        run: |\n          curl -LJO https://github.com/dag-andersen/argocd-diff-preview/releases/download/v0.1.24/argocd-diff-preview-Linux-x86_64.tar.gz\n          tar -xvf argocd-diff-preview-Linux-x86_64.tar.gz\n          sudo mv argocd-diff-preview /usr/local/bin\n          argocd-diff-preview --version\n\n      - name: Generate Diff\n        run: |\n          argocd-diff-preview \\\n            --repo ${{ github.repository }} \\\n            --base-branch main \\\n            --target-branch refs/pull/${{ github.event.number }}/merge \\\n            --argocd-namespace=argocd-diff-preview \\\n            --create-cluster=false\n\n      - name: Comment preview\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Key configuration points:</p> <ul> <li><code>runs-on: argocd-diff-runner</code> - Must match your <code>runnerScaleSetName</code> from Step 2</li> <li><code>--argocd-namespace=argocd-diff-preview</code> - Change if your Argo CD uses a different namespace</li> <li><code>--create-cluster=false</code> - Critical flag that tells the tool to use a pre-provisioned cluster</li> </ul>"},{"location":"reusing-clusters/self-hosted-gh-runner/#option-b-using-docker","title":"Option B: Using Docker","text":"<p>If you prefer to use the Docker image (requires Docker installed on runner pods):</p> .github/workflows/diff-preview-docker.yml<pre><code>      - name: Generate Diff\n        run: |\n          docker run \\\n            --network host \\\n            -v ~/.kube:/root/.kube \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/output:/output \\\n            -v $(pwd)/base-branch:/base-branch \\\n            -v $(pwd)/target-branch:/target-branch \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.24 \\\n            --argocd-namespace=argocd-diff-preview \\\n            --create-cluster=false\n</code></pre> <p>Important Docker considerations:</p> <ul> <li><code>--network host</code> - Allows the container to access the cluster using the runner's network</li> <li><code>-v ~/.kube:/root/.kube</code> - Mounts kubeconfig for cluster access</li> <li><code>-v /var/run/docker.sock:/var/run/docker.sock</code> - Required if using Docker-in-Docker features</li> <li>Docker must be installed and accessible on the runner pods</li> </ul>"},{"location":"reusing-clusters/self-hosted-gh-runner/#expected-output","title":"Expected Output","text":"<p>When the workflow runs successfully, you'll see output similar to this in your GitHub Actions logs:</p> <pre><code>\u2728 Running with:\n\u2728 - reusing cluster with Argo CD pre-installed\n\u2728 - base-branch: main\n\u2728 - target-branch: refs/pull/123/merge\n\u2728 - output-folder: ./output\n\u2728 - argocd-namespace: argocd-diff-runner\n\u2728 - repo: your-org/your-repo\n\u2728 - timeout: 180 seconds\n\ud83d\udd11 Unique ID for this run: 60993\n\ud83e\udd16 Fetching all files for branch (branch: main)\n\ud83e\udd16 Found 52 files in dir base-branch (branch: main)\n...\n\ud83e\udd91 Logging in to Argo CD through CLI...\n\ud83e\udd91 Logged in to Argo CD successfully\n\ud83e\udd16 Converting ApplicationSets to Applications in both branches\n...\n\ud83e\udd16 Patching 19 Applications (branch: main)\n\ud83e\udd16 Patching 19 Applications (branch: refs/pull/123/merge)\n\ud83e\udd16 Rendered 11 out of 38 applications (timeout in 175 seconds)\n\ud83e\uddfc Waiting for all application deletions to complete...\n\ud83e\uddfc All application deletions completed\n\ud83e\udd16 Got all resources from 19 applications from base-branch and got 19 from target-branch in 7s\n\ud83d\udd2e Generating diff between main and refs/pull/123/merge\n\ud83d\ude4f Please check the ./output/diff.md file for differences\n\u2728 Total execution time: 10s\n</code></pre>"}]}