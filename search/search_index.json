{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Argo CD Diff Preview is a tool that renders the diff between two branches in a Git repository. It is designed to render manifests generated by Argo CD, providing a clear and concise view of the changes between two branches. It operates similarly to Atlantis for Terraform, creating a plan that outlines the proposed changes.</p>"},{"location":"#3-example-pull-requests","title":"3 Example Pull Requests:","text":"<ul> <li>Helm Example | Internal Chart</li> <li>Helm example | External Chart: Nginx</li> <li>Kustomize Example</li> </ul>"},{"location":"#overview_1","title":"Overview","text":"<p>The safest way to make changes to you Helm Charts and Kustomize Overlays in your GitOps repository is to let Argo CD render them for you. This can be done by spinning up an ephemeral cluster in your automated pipelines. Since the diff is rendered by Argo CD itself, it is as accurate as possible.</p> <p>The implementation is actually quite simple. It just follows the steps below:</p>"},{"location":"#10-steps","title":"10 Steps","text":"<ol> <li>Start a local cluster</li> <li>Install Argo CD</li> <li>Add the required credentials (git credentials, image pull secrets, etc.)</li> <li>Fetch all Argo CD applications from your PR branch</li> <li>Point their <code>targetRevision</code> to the Pull Request branch</li> <li>Remove the <code>syncPolicy</code> from the applications (to avoid the applications syncing locally)</li> <li>Apply the modified applications to the cluster</li> <li>Let Argo CD do its magic</li> <li>Extract the rendered manifests from the Argo CD server</li> <li>Repeat steps 4\u20137 for the base branch (main branch)</li> <li>Create a diff between the manifests rendered from each branch</li> <li>Display the diff in the PR</li> </ol>"},{"location":"#features","title":"Features","text":"<ul> <li>Renders manifests generated by Argo CD</li> <li>Does not require access to your real cluster or Argo CD instance. The tool runs in complete isolation.</li> <li>Can be run locally before you open the pull request</li> <li>Works with private repositories and Helm charts</li> <li>Provides a clear and concise view of the changes</li> <li>Render resources from external sources (e.g., Helm charts). For example, when you update the chart version of Nginx, you can get a render of the new output. For example, this is useful to spot changes in default values. PR example. </li> </ul>"},{"location":"#why-do-we-need-this","title":"Why do we need this?","text":"<p>In the Kubernetes world, we often use templating tools like Kustomize and Helm to generate our Kubernetes manifests. These tools make maintaining and streamlining configuration easier across applications and environments. However, they also make it harder to visualize the application's actual configuration in the cluster.</p> <p>Mentally parsing Helm templates and Kustomize patches is hard without rendering the actual output. Thus, making mistakes while modifying an application's configuration is relatively easy.</p> <p>In the field of GitOps and infrastructure as code, all configurations are checked into Git and modified through PRs. The code changes in the PR are reviewed by a human, who needs to understand the changes made to the configuration. This is hard when the configuration is generated through templating tools like Kustomize and Helm.</p>"},{"location":"#argocon-2024-talk","title":"ArgoCon 2024 Talk","text":"<p> <code>argocd-diff-preview</code> was presented at ArgoCon 2024 in Utah, US. The talk covered current tools and methods for visualizing code changes in GitOps workflows and introduced this new approach, which uses ephemeral clusters to render accurate diffs directly on your pull requests.</p> <ul> <li>Talk description: GitOps Safety: Rendering Accurate ArgoCD Diffs Directly on Pull Requests</li> <li>Talk recording: YouTube</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to ArgoCD Diff Preview! Whether you want to fix bugs, add new features, or improve documentation, your help is appreciated.</p> <p>Please check out our contribution guidelines for details on how to set up your development environment, run tests, and submit changes.</p>"},{"location":"application-selection/","title":"Application Selection","text":"<p>Rendering manifests for all applications in your repository on every pull request can be time-consuming, especially in large monorepos. By default, <code>argocd-diff-preview</code> renders all applications it finds, but you can significantly speed up the process by limiting which applications are rendered.</p> <p>This page describes 4 strategies for controlling which applications are rendered:</p> <ol> <li>Rendering only changed applications - Automatically detect and render only applications affected by file changes</li> <li>Ignoring individual applications - Explicitly exclude specific applications from rendering</li> <li>Label selectors - Filter applications based on Kubernetes labels</li> <li>File path regex - Target applications based on their file path location</li> </ol>"},{"location":"application-selection/#1-rendering-only-changed-applications","title":"1. Rendering Only Changed Applications","text":"<p>The most efficient way to optimize rendering is to process only applications that are actually affected by changes in your pull request. This approach uses annotations to define which files each application depends on, then automatically renders only the relevant applications.</p>"},{"location":"application-selection/#option-a-watch-pattern-annotation","title":"Option A: Watch Pattern Annotation","text":"<p>The <code>argocd-diff-preview/watch-pattern</code> annotation allows you to specify which file paths should trigger a render for each application. When files matching the pattern change in a pull request, the application will be rendered.</p> <p>How it works:</p> <ul> <li>Add the <code>argocd-diff-preview/watch-pattern</code> annotation to your Application or ApplicationSet manifests</li> <li>The annotation accepts a comma-separated list of file paths or regex patterns</li> <li>Applications are automatically rendered when their watch-patterns match changed files</li> <li>Applications are always rendered if their own manifest file changes (no need to include it in the pattern)</li> </ul> <p>Note</p> <p>The <code>argocd-diff-preview/watch-pattern</code> annotation must exist in the base branch for filtering to work. This ensures the tool knows which files to watch before comparing branches.</p> <p>Example: Application with Watch Pattern</p> <p>In this example, the <code>my-app</code> application will be rendered if: - Changes are made to files in <code>examples/helm/charts/myApp/</code> (matching the regex pattern <code>examples/helm/charts/myApp/.*</code>) - Changes are made to the <code>examples/helm/values/filtered.yaml</code> file - Changes are made to the Application manifest itself (automatic behavior)</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/watch-pattern: |\n      examples/helm/charts/myApp/.*,\n      examples/helm/values/filtered.yaml\nspec:\n  sources:\n    - repoURL: https://github.com/dag-andersen/argocd-diff-preview\n      ref: local-files\n    - path: examples/helm/charts/myApp\n      repoURL: https://github.com/dag-andersen/argocd-diff-preview\n      helm:\n        valueFiles:\n          - $local-files/examples/helm/values/filtered.yaml\n  # ...\n</code></pre> <p>Example: ApplicationSet with Watch Pattern</p> <p>For ApplicationSets, add the annotation in two places: - On the ApplicationSet itself (<code>metadata.annotations</code>) - On the template that generates applications (<code>spec.template.metadata.annotations</code>)</p> <p>The template annotation can use generator variables like <code>{{ .path.basename }}</code> to create application-specific watch-patterns.</p> ApplicationSet<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: my-appset\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/watch-pattern: |\n      examples/helm/charts/.*, \n      examples/helm/values/filtered.yaml\nspec:\n  generators:\n    - git:\n        repoURL: https://github.com/dag-andersen/argocd-diff-preview\n        revision: HEAD\n        directories:\n          - path: examples/helm/charts/*\n  template:\n    metadata:\n      name: '{{ .path.basename }}'\n      annotations:\n        argocd-diff-preview/watch-pattern: |\n          examples/helm/charts/{{ .path.basename }}/.*, \n          examples/helm/values/filtered.yaml\n    spec:\n      project: {{ .path.basename }}\n      source:\n        repoURL: https://github.com/dag-andersen/argocd-diff-preview\n        targetRevision: HEAD\n        path: '{{ .path.path }}'\n        helm:\n          valueFiles:\n            - ../../values/filtered.yaml\n            - values.yaml\n  # ...\n</code></pre>"},{"location":"application-selection/#option-b-argo-cd-manifest-paths-annotation-beta","title":"Option B: Argo CD Manifest Paths Annotation (BETA)","text":"<p>As an alternative to the <code>watch-pattern</code> annotation, you can use Argo CD's native <code>argocd.argoproj.io/manifest-generate-paths</code> annotation. This annotation serves a similar purpose: defining which file paths should trigger a render for the application.</p> <p>Example:</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: guestbook\n  namespace: argocd\n  annotations:\n    argocd.argoproj.io/manifest-generate-paths: .\nspec:\n  source:\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n    targetRevision: HEAD\n    path: guestbook\n  # ...\n</code></pre> <p>For more details on this annotation, see the Argo CD documentation.</p>"},{"location":"application-selection/#implementing-changed-file-detection-in-cicd","title":"Implementing Changed File Detection in CI/CD","text":"<p>Once you've added watch-pattern annotations to your applications, configure your CI/CD pipeline to detect changed files and use them for filtering. Here are two approaches:</p>"},{"location":"application-selection/#approach-1-automatic-detection-recommended","title":"Approach 1: Automatic Detection (Recommended)","text":"<p>The simplest approach is to use the <code>--auto-detect-files-changed</code> flag. The tool will automatically determine which files changed in the pull request and match them against the watch-patterns.</p> <p>Configuration options:</p> <ul> <li><code>--auto-detect-files-changed=true</code> - Enables automatic file change detection</li> <li><code>--watch-if-no-watch-pattern-found=true</code> - Renders applications that don't have a watch-pattern annotation </li> <li><code>--watch-if-no-watch-pattern-found=false</code> - Skips applications that don't have a watch-pattern annotation (default behavior)</li> </ul> <p>How it works: - Applications with a <code>watch-pattern</code> annotation are rendered only if their patterns match changed files - Applications without a <code>watch-pattern</code> annotation follow the <code>--watch-if-no-watch-pattern-found</code> setting - Applications are always rendered if their own manifest file changes</p> .github/workflows/generate-diff.yml<pre><code>name: Generate Diff\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  generate-diff:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            dagandersen/argocd-diff-preview:v0.1.17 \\\n            --target-branch=refs/pull/${{ github.event.number }}/merge \\\n            --repo=${{ github.repository }} \\\n            --auto-detect-files-changed=true \\\n            --watch-if-no-watch-pattern-found=true\n</code></pre>"},{"location":"application-selection/#approach-2-manual-file-detection","title":"Approach 2: Manual File Detection","text":"<p>For more control over file detection, you can manually detect changed files and pass them to the tool using the <code>--files-changed</code> option or <code>FILES_CHANGED</code> environment variable. This approach is useful if you have custom logic for determining which files matter.</p> <p>How it works: - Use a GitHub Action like <code>tj-actions/changed-files</code> to detect changed files - Pass the file list to <code>argocd-diff-preview</code> - Only applications with matching <code>watch-pattern</code> annotations will be rendered - Applications without a <code>watch-pattern</code> annotation follow the <code>--watch-if-no-watch-pattern-found</code> setting</p> .github/workflows/generate-diff.yml<pre><code>name: Generate Diff\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  generate-diff:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - name: Get changed files\n        id: changed-files\n        uses: tj-actions/changed-files@v45\n\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            -e FILES_CHANGED=\"${{ steps.changed-files.outputs.all_changed_files }}\" \\\n            dagandersen/argocd-diff-preview:v0.1.19\n</code></pre>"},{"location":"application-selection/#2-ignoring-individual-applications","title":"2. Ignoring Individual Applications","text":"<p>Sometimes you need to permanently exclude specific applications from diff previews. This is useful for applications that: - Are rarely updated and don't need review - Generate very large diffs that aren't useful - Have sensitive information you don't want in pull request comments</p> <p>Add the <code>argocd-diff-preview/ignore: \"true\"</code> annotation to any Application or ApplicationSet manifest to skip it during rendering.</p> <p>Example: Ignoring an Application</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/ignore: \"true\"\nspec:\n  # ...\n</code></pre> <p>Example: Ignoring an ApplicationSet</p> ApplicationSet<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ApplicationSet\nmetadata:\n  name: my-appset\n  namespace: argocd\n  annotations:\n    argocd-diff-preview/ignore: \"true\"\nspec:\n  # ...\n</code></pre> <p>Combining with other filters</p> <p>The ignore annotation takes precedence over other selection methods. An ignored application will never be rendered, even if it matches label selectors or file patterns.</p>"},{"location":"application-selection/#3-label-selectors","title":"3. Label Selectors","text":"<p>Label selectors provide a flexible way to filter applications using Kubernetes labels. This is particularly useful when you organize your applications by team, environment, or criticality.</p> <p>Use the <code>--selector</code> flag with label matching expressions. The tool supports standard Kubernetes label selector operators: - <code>=</code> or <code>==</code> for equality - <code>!=</code> for inequality</p> <p>Example: Filter by team</p> <pre><code>argocd-diff-preview --selector \"team=platform\"\n</code></pre> <p>This command renders only applications with the label <code>team: platform</code>. All applications without this label are skipped.</p> <p>Example: Application with labels</p> Application<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\n  namespace: argocd\n  labels:\n    team: platform\n    environment: production\nspec:\n  # ...\n</code></pre> <p>Common use cases: - Filter by team: <code>--selector \"team=platform\"</code> - Filter by environment: <code>--selector \"environment=production\"</code> - Exclude specific values: <code>--selector \"criticality!=low\"</code></p> <p>Multiple selectors</p> <p>You can combine multiple label selectors to create more specific filters based on your application organization structure.</p>"},{"location":"application-selection/#4-application-file-path-regex","title":"4. Application File Path Regex","text":"<p>File path regex filtering is useful for targeting applications based on their location in your repository structure. This is especially helpful in monorepos where different teams or projects maintain applications in separate directories.</p> <p>Use the <code>--file-regex</code> flag to specify a regular expression pattern. Only Application and ApplicationSet manifests whose file paths match the pattern will be rendered.</p> <p>Example: Filter by team directory</p> <p>If Team A maintains their applications in a <code>team-a/</code> directory:</p> <pre><code>argocd-diff-preview --file-regex=\"team-a/\"\n</code></pre> <p>This renders only applications whose file paths contain <code>team-a/</code>, such as: - <code>apps/team-a/frontend.yaml</code> - <code>team-a/services/backend.yaml</code> - <code>infrastructure/team-a/database.yaml</code></p> <p>Example: Filter by multiple directories</p> <pre><code>argocd-diff-preview --file-regex=\"(team-a|team-b)/\"\n</code></pre> <p>This renders applications from either <code>team-a/</code> or <code>team-b/</code> directories.</p> <p>Common patterns: - Single team: <code>--file-regex=\"team-a/\"</code> - Multiple teams: <code>--file-regex=\"(team-a|team-b)/\"</code> - Environment-specific: <code>--file-regex=\"production/\"</code> - Exclude directories: <code>--file-regex=\"^(?!.*/deprecated/).*$\"</code></p>"},{"location":"demo/","title":"Try demo locally with 3 simple commands!","text":"<p>First, make sure Docker is running. Run <code>docker ps</code> to check if it's running.</p> <p>Second, run the following 3 commands:</p> <pre><code>git clone https://github.com/dag-andersen/argocd-diff-preview base-branch --depth 1 -q \n\ngit clone https://github.com/dag-andersen/argocd-diff-preview target-branch --depth 1 -q -b helm-example-3\n\ndocker run \\\n   --network host \\\n   -v /var/run/docker.sock:/var/run/docker.sock \\\n   -v $(pwd)/output:/output \\\n   -v $(pwd)/base-branch:/base-branch \\\n   -v $(pwd)/target-branch:/target-branch \\\n   -e TARGET_BRANCH=helm-example-3 \\\n   -e REPO=dag-andersen/argocd-diff-preview \\\n   dagandersen/argocd-diff-preview:v0.1.19\n</code></pre> <p>and the output would be something like this:</p> <pre><code>\u2728 Running with:\n\u2728 - local-cluster-tool: Kind\n\u2728 - base-branch: main\n\u2728 - target-branch: helm-example-3\n\u2728 - secrets-folder: ./secrets\n\u2728 - output-folder: ./output\n\u2728 - repo: dag-andersen/argocd-diff-preview\n\u2728 - timeout: 180 seconds\n\ud83d\ude80 Creating cluster...\n\ud83d\ude80 Cluster created successfully\n\ud83e\udd91 Installing Argo CD Helm Chart version: 'latest'\n\ud83e\udd91 Installing Argo CD Helm Chart\n\ud83e\udd91 Waiting for Argo CD to start...\n\ud83e\udd91 Argo CD is now available\n\ud83e\udd91 Logging in to Argo CD through CLI...\n\ud83e\udd91 Argo CD installed successfully\n\ud83e\udd37 No secrets found in ./secrets\n\ud83e\udd16 Fetching all files in dir: base-branch\n\ud83e\udd16 Patching applications for branch: main\n\ud83e\udd16 Patching 4 Argo CD Application[Sets] for branch: main\n\ud83e\udd16 Fetching all files in dir: target-branch\n\ud83e\udd16 Patching applications for branch: helm-example-3\n\ud83e\udd16 Patching 4 Argo CD Application[Sets] for branch: helm-example-3\n\ud83c\udf1a Getting resources from base\n\u23f3 Waiting for 4 out of 4 applications to become 'OutOfSync'. Retrying in 5 seconds. Timeout in 180 seconds...\n\ud83c\udf1a Got all resources from 4 applications for base\n\ud83e\uddfc Removing applications\n\ud83e\uddfc Removed applications successfully\n\ud83c\udf1a Getting resources from target\n\u23f3 Waiting for 3 out of 4 applications to become 'OutOfSync'. Retrying in 5 seconds. Timeout in 180 seconds...\n\ud83c\udf1a Got all resources from 4 applications for target\n\ud83d\udca5 Deleting cluster...\n\ud83d\udd2e Generating diff between main and helm-example-3\n\ud83d\ude4f Please check the ./output/diff.md file for differences\n\ud83c\udf89 Done in 99 seconds\n</code></pre> <p>Finally, you can view the diff by running <code>cat ./output/diff.md</code>. The diff should look something like this</p> <p>Questions, issues, or suggestions</p> <p>If you experience issues or have any questions, please open an issue in the repository! \ud83d\ude80</p>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#does-the-tool-work-with-applicationsets","title":"Does the tool work with <code>ApplicationSets</code>?","text":"<p>Short answer: : Yes.</p> <p>Longer Answer: Yes, but how well it works depends on the complexity of your generators.</p> <ul> <li> <p>List generator:   Yes, no issues reported</p> </li> <li> <p>Cluster generator:   Yes, but you have to add the ClusterSecrets to the <code>secrets</code> folder. Similar to how the secrets are provided here</p> </li> <li> <p>Git generator:   Yes, no issues reported</p> </li> <li> <p>Matrix generator:   Yes, no issues reported</p> </li> <li> <p>Merge generator:   Yes, no issues reported</p> </li> <li> <p>Plugin generator:    Should work, but not tested. Read more on how to install a plugin here. Related Issue: #40</p> </li> <li> <p>Pull Request generator:    Should work, but not tested.</p> </li> <li> <p>SCM Provider generator:   Not tested</p> </li> <li> <p>Cluster Decision Resource generator:   Not tested</p> </li> </ul>"},{"location":"faq/#does-it-work-with-config-management-plugins-cmp","title":"Does it work with Config Management Plugins (CMP)","text":"<p>Yes. More info docs</p>"},{"location":"faq/#does-it-work-with-git-providers-other-than-github-and-gitlab","title":"Does it work with Git providers other than GitHub and GitLab?","text":"<p>Short answer: Yes.</p> <p>Longer answer: In theory, yes, but not all providers have been tested. If you are using a different Git provider and encounter issues, please open an issue in the repository. Additionally, if you have successfully used the tool with a different provider, consider contributing to the documentation so others can benefit from a working example \u2764\ufe0f</p> <p>Relevant issue: #94</p>"},{"location":"faq/#does-it-work-with-the-apps-of-apps-pattern","title":"Does it work with the Apps of Apps Pattern?","text":"<p>Short answer: Yes, but it depends on your setup.</p> <p>Longer answer: The Apps of Apps Pattern can be configured in many ways, making it challenging to handle all cases. This tool identifies and renders all resources with <code>kind: Application</code> or <code>kind: ApplicationSet</code>. If your Applications or ApplicationSets are written as plain manifests in your repository, the tool will work seamlessly. However, if you have an Application that deploys a Helm chart, which then deploys the rest of your Applications, you will need to render the Helm chart before running the tool.</p> <p>Relevant issue: #75</p>"},{"location":"faq/#why-cant-the-tool-automatically-render-my-helm-charts-or-kustomize-templates","title":"Why can't the tool automatically render my Helm Charts or Kustomize templates?","text":"<p>Helm and Kustomize configurations are inherently complex:</p> <ul> <li>Helm: Any YAML file can be used as a values file for Helm charts, making it impossible for the tool to automatically determine which YAML files should be used as values files and which Helm charts they belong to.</li> <li>Kustomize: Overlays in Kustomize can be chained in various ways. The tool cannot reliably figure out which overlays to use or skip.</li> </ul> <p>Because of this, users must render their Helm charts and Kustomize templates before running the tool.</p> <p>The tool is rather conservative in making assumptions about how Applications are rendered, with the goal of avoiding false positives.</p> <p>More info: docs</p>"},{"location":"faq/#does-it-work-with-a-distributed-argo-cd-repository-setup","title":"Does it work with a distributed Argo CD repository setup?","text":"<p>Short answer: Maybe... It depends on what you are trying to achieve.</p> <p>Longer answer: The tool is not specifically designed to work with a distributed Argo CD repository setup, where applications and their manifests are spread across multiple repositories.</p>"},{"location":"faq/#how-do-i-speed-up-the-tool","title":"How do I speed up the tool?","text":"<p>Short answer: Limit the number of applications rendered.</p> <p>Longer answer: Rendering the manifests for all applications in the repository on each pull request can be time-consuming. Limiting the number of applications rendered can significantly speed up the process. By default, <code>argocd-diff-preview</code> renders all applications in the repository.</p> <p>Check out the full documentation to learn how to limit the number of applications rendered.</p>"},{"location":"generated-applications/","title":"Helm/Kustomize generated ArgoCD applications","text":"<p><code>argocd-diff-preview</code> will only look for YAML files in the repository with <code>kind: Application</code> or <code>kind: ApplicationSet</code>. If your applications are generated from a Helm chart or Kustomize template, you will have to add a step in the pipeline that renders the chart/template.</p> <p>Helm and Kustomize examples:</p> <p>.github/workflows/generate-diff.yml<pre><code>jobs:\n  build:\n    ...\n    steps:\n      ...\n    - uses: actions/checkout@v4\n      with:\n        path: pull-request\n\n    - name: Generate with helm chart\n      run: helm template pull-request/some/path/my-chart &gt; pull-request/rendered-apps.yaml\n\n    - name: Generate with kustomize\n      run: kustomize build pull-request/some/path/my-kustomize &gt; pull-request/rendered-apps.yaml\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          ...\n</code></pre> This will place the rendered manifests inside the <code>pull-request</code> folder, and the tool will pick them up.</p>"},{"location":"ignoring-lines/","title":"Ignore specific lines in the diff preview","text":"<p>Since this tool only highlights diffs between branches, it is important to stay up to date with your main branch. If your main branch is updated often with new tags for you container images, it can be hard to keep up with the newest changes.</p>"},{"location":"ignoring-lines/#example-1","title":"Example 1:","text":"<p>You might see a lot of previews including simple changes like <code>image: my-image:v1.0.0</code> to <code>image: my-image:v1.0.1</code>.</p> <pre><code>diff --git base/deployment target/deployment\n@@ -3,38 +3,38 @@ template:\n    spec:\n      containers:\n        - name: my-app\n-         image: dag-andersen/my-app:v1.0.1\n+         image: dag-andersen/my-app:v1.0.2\n          ports:\n            - containerPort: 80\n</code></pre> <p>To avoid this, you can ignore lines in the diff by using the <code>--diff-ignore</code> option.</p> <pre><code>argocd-diff-preview --diff-ignore=\"v[1,9]+.[1,9]+.[1,9]+\"\n</code></pre>"},{"location":"ignoring-lines/#example-2","title":"Example 2:","text":"<p>In some cases, Helm Charts generate new values each time they are installed. When this happens, the diff will appear in every pull request. To avoid this, you can ignore these values by using the <code>--diff-ignore</code> option.</p> <pre><code>   name: example-name\n webhooks:\n - admissionReviewVersions:\n   - v1\n   clientConfig:\n-    caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURLR ...\n+    caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURKe ...\n     service:\n       name: example-name\n       port: 443\n   failurePolicy: Fail\n   name: vbinding.kb.io\n</code></pre> <pre><code>argocd-diff-preview --diff-ignore=\"caBundle\"\n</code></pre> <p>This will hide all lines that contain the word <code>caBundle</code>.</p>"},{"location":"options/","title":"Options","text":"<p>This document describes all the available options for <code>argocd-diff-preview</code>. Options can be provided via command-line flags or environment variables.</p>"},{"location":"options/#usage","title":"Usage","text":"<pre><code>argocd-diff-preview [FLAGS] [OPTIONS] --repo &lt;repo&gt; --target-branch &lt;target-branch&gt;\n</code></pre>"},{"location":"options/#required-options","title":"Required Options","text":"Flag Environment Variable Description <code>--repo &lt;repo&gt;</code> <code>REPO</code> Git Repository in format <code>OWNER/REPO</code> (e.g., <code>dag-andersen/argocd-diff-preview</code>) <code>--target-branch &lt;target-branch&gt;</code>, <code>-t</code> <code>TARGET_BRANCH</code> Target branch name (the branch you want to compare with the base branch)"},{"location":"options/#flags","title":"Flags","text":"Flag Environment Variable Default Description <code>--create-cluster</code> <code>CREATE_CLUSTER</code> <code>true</code> Create a new cluster if it doesn't exist <code>--auto-detect-files-changed</code> <code>AUTO_DETECT_FILES_CHANGED</code> <code>false</code> Auto detect files changed between branches <code>--watch-if-no-watch-pattern-found</code> <code>WATCH_IF_NO_WATCH_PATTERN_FOUND</code> <code>false</code> Render applications without watch-pattern annotation <code>--debug</code>, <code>-d</code> <code>DEBUG</code> <code>false</code> Activate debug mode <code>--dry-run</code> <code>DRY_RUN</code> <code>false</code> Show which applications would be processed without creating a cluster or generating a diff <code>--ignore-invalid-watch-pattern</code> <code>IGNORE_INVALID_WATCH_PATTERN</code> <code>false</code> Ignore invalid watch-pattern Regex on Applications <code>--keep-cluster-alive</code> <code>KEEP_CLUSTER_ALIVE</code> <code>false</code> Keep cluster alive after the tool finishes <code>--kind-internal</code> <code>KIND_INTERNAL</code> <code>false</code> Use the kind cluster's internal address in the kubeconfig (allows connecting to the cluster when running the CLI in a container) <code>--version</code>, <code>-v</code> - - Prints version information"},{"location":"options/#options_1","title":"Options","text":"Option Environment Variable Default Description <code>--argocd-chart-version &lt;version&gt;</code> <code>ARGOCD_CHART_VERSION</code> <code>latest</code> Argo CD Helm Chart version <code>--argocd-chart-name &lt;name&gt;</code> <code>ARGOCD_CHART_NAME</code> <code>argo</code> Argo CD Helm Chart name <code>--argocd-chart-url &lt;url&gt;</code> <code>ARGOCD_CHART_URL</code> <code>https://argoproj.github.io/argo-helm</code> Argo CD Helm Chart URL <code>--argocd-chart-repo-username &lt;username&gt;</code> <code>ARGOCD_CHART_REPO_USERNAME</code> - Argo CD Helm Chart Private repository username <code>--argocd-chart-repo-password &lt;passwordl&gt;</code> <code>ARGOCD_CHART_REPO_PASSWORD</code> - Argo CD Helm Chart Private repository password <code>--argocd-namespace &lt;namespace&gt;</code> <code>ARGOCD_NAMESPACE</code> <code>argocd</code> Namespace to use for Argo CD <code>--base-branch &lt;branch&gt;</code>, <code>-b</code> <code>BASE_BRANCH</code> <code>main</code> Base branch name <code>--cluster &lt;tool&gt;</code> <code>CLUSTER</code> <code>auto</code> Local cluster tool. Options: <code>kind</code>, <code>minikube</code>, <code>k3d</code>, <code>auto</code> <code>--cluster-name &lt;name&gt;</code> <code>CLUSTER_NAME</code> <code>argocd-diff-preview</code> Cluster name (only for kind &amp; k3d) <code>--diff-ignore &lt;pattern&gt;</code>, <code>-i</code> <code>DIFF_IGNORE</code> - Ignore lines in diff. Example: <code>v[1,9]+.[1,9]+.[1,9]+</code> for ignoring version changes <code>--file-regex &lt;regex&gt;</code>, <code>-r</code> <code>FILE_REGEX</code> - Regex to filter files. Example: <code>/apps_.*\\.yaml</code> <code>--files-changed &lt;files&gt;</code> <code>FILES_CHANGED</code> - List of files changed between branches (comma, space or newline separated) <code>--k3d-options &lt;options&gt;</code> <code>K3D_OPTIONS</code> - k3d options (only for k3d) <code>--kind-options &lt;options&gt;</code> <code>KIND_OPTIONS</code> - kind options (only for kind) <code>--line-count &lt;count&gt;</code>, <code>-c</code> <code>LINE_COUNT</code> <code>7</code> Generate diffs with \\&lt;n&gt; lines of context <code>--log-format &lt;format&gt;</code> <code>LOG_FORMAT</code> <code>human</code> Log format. Options: <code>human</code>, <code>json</code> <code>--max-diff-length &lt;length&gt;</code> <code>MAX_DIFF_LENGTH</code> <code>65536</code> Max diff message character count (only limits the generated Markdown file) <code>--output-folder &lt;folder&gt;</code>, <code>-o</code> <code>OUTPUT_FOLDER</code> <code>./output</code> Output folder where the diff will be saved <code>--redirect-target-revisions &lt;revs&gt;</code> <code>REDIRECT_TARGET_REVISIONS</code> - List of target revisions to redirect <code>--secrets-folder &lt;folder&gt;</code>, <code>-s</code> <code>SECRETS_FOLDER</code> <code>./secrets</code> Secrets folder where the secrets are read from <code>--selector &lt;selector&gt;</code>, <code>-l</code> <code>SELECTOR</code> - Label selector to filter on (e.g., <code>key1=value1,key2=value2</code>) <code>--timeout &lt;seconds&gt;</code> <code>TIMEOUT</code> <code>180</code> Set timeout in seconds <code>--title &lt;title&gt;</code> <code>TITLE</code> <code>Argo CD Diff Preview</code> Custom title for the markdown output"},{"location":"output/","title":"Output formats","text":""},{"location":"output/#markdown","title":"Markdown","text":"<p>The tool creates a Markdown file at <code>./output/diff.md</code>.</p> <p></p>"},{"location":"output/#html","title":"HTML","text":"<p>The tool creates an HTML file at <code>./output/diff.html</code>.</p> <p></p>"},{"location":"output/#fully-rendered-manifests","title":"Fully rendered manifests","text":"<p>After rendering the manifests for each branch, the tool stores the compared output in two files: <code>./output/base-branch.yaml</code> and <code>./output/target-branch.yaml</code>. These files are long YAML documents containing all the rendered manifests.</p> <p>You can pass this output into any tool you like. For example, you could feed those files into kube-score to check whether the score of your new branch goes up or down.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#debug-mode","title":"Debug Mode","text":"<p>If you are having trouble with the tool, you can enable debug mode to get more information about what is going wrong. To enable debug mode run the tool with the <code>--debug</code> flag.</p> <p>If that doesn't help or you still have questions, please open an issue in the repository! </p>"},{"location":"getting-started/custom-argo-cd-installation/","title":"Custom Argo CD Installation","text":"<p>Argo CD is installed using a Helm Chart. You can specify the Chart version with the <code>--argocd-chart-version</code> option. It defaults to the latest version.</p> <p>You can modify the Argo CD Helm Chart installation by providing the tool with a <code>values.yaml</code> file and mounting it in the <code>argocd-config</code> folder within the container. Check out all the available values in the Argo CD Helm Chart.</p> <p>Example:</p> <p>Here we set <code>configs.cm.\"kustomize.buildOptions\"</code> in the Chart.</p> .github/workflows/generate-diff.yml<pre><code>jobs:\n  build:\n    ...\n    steps:\n      ...\n    - name: Set Argo CD Custom Values\n      run: |\n        cat &gt; values.yaml &lt;&lt; \"EOF\"\n        # set whatever helm values you want\n        configs:\n          cm:\n            kustomize.buildOptions: --load-restrictor LoadRestrictionsNone --enable-helm\n        EOF\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          -v $(pwd)/pull-request:/target-branch \\\n          -v $(pwd)/values.yaml:/argocd-config/values.yaml \\   \u2b05\ufe0f Mount values.yaml\n          ...\n</code></pre>"},{"location":"getting-started/custom-argo-cd-installation/#argo-cd-config-management-plugins-cmp","title":"Argo CD Config Management Plugins (CMP)","text":"<p>You can install any Argo CD Config Management Plugin that is supported through the Argo CD Helm Chart.</p> <p>Example:</p> <p>This example installs the ArgoCD Lovely plugin using the <code>values.yaml</code> file.</p> .github/workflows/generate-diff.yml<pre><code>jobs:\n  build:\n    ...\n    steps:\n      ...\n    - name: Set Argo CD Custom Values\n      run: |\n        cat &gt; values.yaml &lt;&lt; \"EOF\"\n        repoServer:\n          extraContainers:\n          # ArgoCD Lovely plugin - https://github.com/crumbhole/argocd-lovely-plugin\n            - name: lovely-plugin\n              image: ghcr.io/crumbhole/lovely:1.1.1\n              securityContext:  \n                runAsNonRoot: true\n                runAsUser: 999\n              volumeMounts:\n                  # Import the repo-server's plugin binary\n                - mountPath: /var/run/argocd\n                  name: var-files\n                - mountPath: /home/argocd/cmp-server/plugins\n                  name: plugins\n                - mountPath: /tmp\n                  name: lovely-tmp\n          volumes:\n            - emptyDir: {}\n              name: lovely-tmp\n        EOF\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          -v $(pwd)/pull-request:/target-branch \\\n          -v $(pwd)/values.yaml:/argocd-config/values.yaml \\   \u2b05\ufe0f Mount values.yaml\n          ...\n</code></pre> <p>Questions, issues, or suggestions</p> <p>If you experience issues or have any questions, please open an issue in the repository! \ud83d\ude80</p>"},{"location":"getting-started/github-actions-workflow/","title":"GitHub Actions Workflow","text":""},{"location":"getting-started/github-actions-workflow/#public-repositories","title":"Public repositories","text":"<p>If your repository is public and only uses public Helm charts, you can use the following GitHub Actions workflow to generate a diff between the main branch and the pull request branch. The diff will then be posted as a comment on the pull request.</p> .github/workflows/generate-diff.yml<pre><code>name: Argo CD Diff Preview\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.19\n\n      - name: Post diff as comment\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Instead of using <code>refs/pull/${{ github.event.number }}/merge</code>, you could also use <code>${{ github.head_ref }}</code> or simply specify the branch name manually.  </p> <p>More information about this can be found in this blog post</p>"},{"location":"getting-started/github-actions-workflow/#private-repositories-and-helm-charts","title":"Private repositories and Helm Charts","text":"<p>In the simple code examples above, we do not provide the cluster with any credentials, which only works if the image/Helm Chart registry and the Git repository are public. Since your repository might not be public you need to provide the tool with the necessary read-access credentials for the repository. This can be done by placing the Argo CD repo secrets in folder mounted at <code>/secrets</code>. When the tool starts, it will simply run <code>kubectl apply -f /secrets</code> to apply every resource to the cluster, before starting the rendering process.</p> .github/workflows/generate-diff.yml<pre><code>...\n    - uses: actions/checkout@v4\n      with:\n        ref: main\n        path: main\n\n    - name: Prepare secrets\n      run: |\n        mkdir secrets\n        cat &gt; secrets/secret.yaml &lt;&lt; \"EOF\"\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: private-repo\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repo-creds\n        stringData:\n          url: https://github.com/${{ github.repository }}\n          password: ${{ secrets.GITHUB_TOKEN }}  \u2b05\ufe0f Short-lived GitHub Token\n          username: not-used\n        EOF\n\n    - name: Generate Diff\n      run: |\n        docker run \\\n          --network=host \\\n          -v /var/run/docker.sock:/var/run/docker.sock \\\n          -v $(pwd)/main:/base-branch \\\n          -v $(pwd)/pull-request:/target-branch \\\n          -v $(pwd)/output:/output \\\n          -v $(pwd)/secrets:/secrets \\           \u2b05\ufe0f Mount the secrets folder\n          -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n          -e REPO=${{ github.repository }} \\\n          dagandersen/argocd-diff-preview:v0.1.19\n</code></pre> <p>If your ArgoCD Applications use SSH to access the private repositories, then you need to configure the secret above using SSH as well.</p> .github/workflows/generate-diff.yml<pre><code>    - name: Prepare secrets\n      run: |\n        mkdir secrets\n        cat &gt; secrets/secret.yaml &lt;&lt; EOF\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: private-repo\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repo-creds\n        stringData:\n          type: git\n          url: git@github.com/${{ github.repository }}\n          sshPrivateKey: |\n        $(echo \"${{ secrets.REPO_ACCESS_SSH_PRIVATE_KEY }}\" | sed 's/^/    /') \u2b05\ufe0f Private SSH key with proper indentation\n        EOF\n</code></pre> <p>If you get this type of error:</p> <pre><code>failed to apply secrets: failed to apply secret secret.yaml: failed to apply manifest: failed to convert new object (namespace/secret-name; /v1, Kind=Secret) to proper version: unable to convert unstructured object to /v1, Kind=Secret: error decoding from json: illegal base64 data at input byte 76 from folder: ./secrets\n</code></pre> <p>it is because <code>base64</code> wraps encoded lines after 76 characters by default:</p> <pre><code>-w, --wrap=COLS\n    Wrap encoded lines after COLS character (default 76). Use 0 to disable line wrapping.\n</code></pre> <p>so you need to use the following alternative:</p> .github/workflows/generate-diff.yml<pre><code>    - name: Prepare secrets\n      run: |\n        mkdir -p secrets\n        SSH_PRIVATE_KEY_B64=$(echo \"${{ secrets.REPO_ACCESS_SSH_PRIVATE_KEY }}\" | base64 -w 0)\n        URL_B64=$(echo \"git@github.com/${{ github.repository }}\" | base64 -w 0)\n        cat &gt; secrets/secret.yaml &lt;&lt;-EOF\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: github-repo-ssh\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repo-creds\n        data:\n          url: \"${URL_B64}\"\n          sshPrivateKey: \"${SSH_PRIVATE_KEY_B64}\"\n        EOF\n</code></pre> <p>If Helm Charts are stored as OCI images in a Docker registry (such as AWS ECR), additional fields must be added to the <code>stringData</code> section as shown below. .github/workflows/generate-diff.yml<pre><code>    - name: Prepare secrets\n      run: |\n        mkdir secrets\n        cat &gt; secrets/secret.yaml &lt;&lt; \"EOF\"\n        apiVersion: v1\n        kind: Secret\n        metadata:\n          name: private-registry\n          namespace: argocd\n          labels:\n            argocd.argoproj.io/secret-type: repository\n        stringData:\n          name: privateRegistry\n          url: ${{ secrets.REGISTRY_URL }}\n          username: ${{ secrets.REGISTRY_USERNAME }}\n          password: ${{ secrets.REGISTRY_PASSWORD }}\n          type: helm\n          enableOCI: \"true\"\n          forceHttpBasicAuth: \"true\"\n        EOF\n</code></pre></p> <p>For more info, see the Argo CD docs</p>"},{"location":"getting-started/gitlab-cicd/","title":"GitLab CI/CD Workflow","text":""},{"location":"getting-started/gitlab-cicd/#public-repositories","title":"Public repositories","text":"<p>If your repository is public and only uses public Helm charts, you can use the following GitLab CI/CD pipeline to generate a diff between the main branch and the merge request branch. The diff will then be posted as a comment on the merge request.</p> <pre><code>default:\n  tags:\n    - gitlab-org-docker\n\nstages:\n  - diff\n\ndiff:\n  stage: diff\n  image: docker:24.0.5\n  services:\n    - name: docker:24.0.5-dind\n  variables:\n    GITLAB_TOKEN: $GITLAB_PAT\n  before_script:\n    - apk add -q curl jq git\n  script:\n    - |\n      echo \"******** Running analysis ********\"\n      git clone ${CI_REPOSITORY_URL} base-branch --depth 1 -q \n      git clone ${CI_REPOSITORY_URL} target-branch --depth 1 -q -b ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}\n      docker run \\\n        --network host \\\n        -v /var/run/docker.sock:/var/run/docker.sock \\\n        -v $(pwd)/output:/output \\\n        -v $(pwd)/base-branch:/base-branch \\\n        -v $(pwd)/target-branch:/target-branch \\\n        -e TARGET_BRANCH=${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} \\\n        -e REPO=${CI_MERGE_REQUEST_PROJECT_PATH} \\\n        dagandersen/argocd-diff-preview:v0.1.19\n    - |\n      DIFF_BODY=$(jq -Rs '.' &lt; $(pwd)/output/diff.md)\n      NOTE_ID=$(curl --silent --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n          \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes\" | \\\n          jq '.[] | select(.body | test(\"Argo CD Diff Preview\")) | .id')\n\n      if [[ -n \"$NOTE_ID\" ]]; then\n          echo \"Deleting existing comment (ID: $NOTE_ID)...\"\n\n          curl --silent --request DELETE --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n              --url \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes/${NOTE_ID}\"\n      fi\n\n      echo \"Adding new comment...\"\n      curl --silent --request POST --header \"PRIVATE-TOKEN: ${GITLAB_TOKEN}\" \\\n          --header \"Content-Type: application/json\" \\\n          --url \"${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes\" \\\n          --data \"{\\\"body\\\": $DIFF_BODY}\" &gt; /dev/null\n\n      echo \"Comment added!\"\n  rules:\n    - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n</code></pre>"},{"location":"getting-started/gitlab-cicd/#private-repositories-and-helm-charts","title":"Private repositories and Helm Charts","text":"<p>In the simple code example above, we do not provide the cluster with any credentials, which only works if the image/Helm Chart registry and the Git repository are public. Since your repository might not be public, you need to provide the tool with the necessary read-access credentials for the repository. This can be done by placing the Argo CD repo secrets in a folder mounted at /secrets. When the tool starts, it will simply run <code>kubectl apply -f /secrets</code> to apply every resource to the cluster before starting the rendering process.</p> <pre><code>...\n  before_script:\n    - apk add -q curl jq git\n    - |\n      mkdir secrets\n      cat &gt; secrets/secret.yaml &lt;&lt; EOF\n      apiVersion: v1\n      kind: Secret\n      metadata:\n        name: private-repo\n        namespace: argocd\n        labels:\n          argocd.argoproj.io/secret-type: repo-creds\n      stringData:\n        url: https://gitlab.com/${CI_PROJECT_PATH}\n        password: ${GITLAB_TOKEN}  \u2b05\ufe0f Short-lived GitLab Token\n        username: token\n      EOF\n\n  script:\n    - |\n      echo \"******** Running analysis ********\"\n      git clone ${CI_REPOSITORY_URL} base-branch --depth 1 -q \n      git clone ${CI_REPOSITORY_URL} target-branch --depth 1 -q -b ${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}\n      docker run \\\n        --network host \\\n        -v /var/run/docker.sock:/var/run/docker.sock \\\n        -v $(pwd)/output:/output \\\n        -v $(pwd)/base-branch:/base-branch \\\n        -v $(pwd)/target-branch:/target-branch \\\n        -v $(pwd)/secrets:/secrets \\           \u2b05\ufe0f Mount the secrets folder\n        -e TARGET_BRANCH=${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME} \\\n        -e REPO=${CI_MERGE_REQUEST_PROJECT_PATH} \\\n        dagandersen/argocd-diff-preview:v0.1.19\n</code></pre> <p>For more info, see the Argo CD docs</p>"},{"location":"getting-started/installation/","title":"Running it locally","text":"DockerBinary"},{"location":"getting-started/installation/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Install: Docker</li> </ul>"},{"location":"getting-started/installation/#usage","title":"Usage","text":"<p>You need to pull down the two branches you want to compare. The first branch will be cloned into the <code>base-branch</code> folder, and the other branch will be cloned into the <code>target-branch</code> folder.</p> <pre><code>git clone https://github.com/&lt;owner&gt;/&lt;repo&gt; base-branch --depth 1 -q -b &lt;branch-a&gt;\n\ngit clone https://github.com/&lt;owner&gt;/&lt;repo&gt; target-branch --depth 1 -q -b &lt;branch-b&gt;\n</code></pre> <p>Then you can run the tool using the following command:</p> <pre><code>docker run \\\n  --network host \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v $(pwd)/output:/output \\\n  -v $(pwd)/base-branch:/base-branch \\\n  -v $(pwd)/target-branch:/target-branch \\\n  -e TARGET_BRANCH=&lt;branch-a&gt; \\\n  -e BASE_BRANCH=&lt;branch-b&gt; \\\n  -e REPO=&lt;owner&gt;/&lt;repo&gt;  \\\n  dagandersen/argocd-diff-preview:v0.1.19\n</code></pre> <p>If base-branch(<code>BASE_BRANCH</code>) is not specified it will default to <code>main</code>.</p>"},{"location":"getting-started/installation/#pre-requisites_1","title":"Pre-requisites","text":"<p>Install:</p> <ul> <li>Git</li> <li>Docker</li> <li>kubectl</li> <li>kind OR minikube</li> <li>Argo CD CLI</li> </ul>"},{"location":"getting-started/installation/#find-the-correct-binary-for-your-operating-system","title":"Find the correct binary for your operating system","text":"<p>Check the releases and find the correct binary for your operating system.</p> <p>Example for downloading and running on macOS:</p> <pre><code>curl -LJO https://github.com/dag-andersen/argocd-diff-preview/releases/download/v0.1.19/argocd-diff-preview-Darwin-x86_64.tar.gz\ntar -xvf argocd-diff-preview-Darwin-x86_64.tar.gz\nsudo mv argocd-diff-preview /usr/local/bin\nargocd-diff-preview --help\n</code></pre>"},{"location":"getting-started/installation/#usage_1","title":"Usage","text":"<p>You need to pull down the two branches you want to compare. The first branch will be cloned into the <code>base-branch</code> folder, and the other branch will be cloned into the <code>target-branch</code> folder.</p> <pre><code>git clone https://github.com/&lt;owner&gt;/&lt;repo&gt; base-branch --depth 1 -q -b &lt;branch-a&gt;\n\ngit clone https://github.com/&lt;owner&gt;/&lt;repo&gt; target-branch --depth 1 -q -b &lt;branch-b&gt;\n</code></pre>"},{"location":"getting-started/installation/#run-the-binary","title":"Run the binary","text":"<pre><code>argocd-diff-preview \\\n  --repo &lt;owner&gt;/&lt;repo-name&gt; \\\n  --base-branch &lt;branch-a&gt; \\\n  --target-branch &lt;branch-b&gt;\n</code></pre> <p>If base-branch is not specified it will default to <code>main</code>.</p>"},{"location":"getting-started/self-hosted-gh-runner/","title":"Self-Hosted GitHub Actions Runners on Kubernetes","text":"<p>Running <code>argocd-diff-preview</code> with self-hosted GitHub Actions runners inside your Kubernetes cluster offers significant advantages over GitHub-hosted runners. Most notably, you can directly access Argo CD's cluster and GitHub/GitLab credentials from the host cluster, eliminating the need to store credentials in your CI/CD pipeline.</p> <p>This guide covers two main approaches for using self-hosted runners with <code>argocd-diff-preview</code>.</p>"},{"location":"getting-started/self-hosted-gh-runner/#approach-1-ephemeral-cluster-inside-runner-pod","title":"Approach 1: Ephemeral Cluster inside Runner Pod","text":"<p>This approach creates a temporary cluster for each diff preview run while reusing credentials from your existing Argo CD installation. It provides isolation for the diff preview while not storing the credentials in your CI/CD pipeline.</p> <p></p>"},{"location":"getting-started/self-hosted-gh-runner/#how-it-works","title":"How It Works","text":"<p>When your self-hosted runner pod runs inside the same cluster as Argo CD:</p> <ol> <li>The runner can access Argo CD secrets using <code>kubectl get secrets -n argocd</code></li> <li>These secrets are extracted and cleaned of cluster-specific metadata</li> <li>The secrets are mounted into the <code>argocd-diff-preview</code> container</li> <li>An ephemeral cluster is created with these credentials pre-configured</li> <li>The diff preview runs with full access to your Git repositories and Helm registries</li> </ol>"},{"location":"getting-started/self-hosted-gh-runner/#benefits","title":"Benefits","text":"<ul> <li>Secure credential access - No need to expose secrets to GitHub. The credentials are read directly from the host cluster and they are always in sync</li> <li>Isolated execution - Each run creates a fresh, ephemeral cluster. Never interacts with your \"real\" Argo CD instance.</li> <li>Easy cleanup - Ephemeral clusters are automatically removed.</li> </ul>"},{"location":"getting-started/self-hosted-gh-runner/#example-workflow","title":"Example Workflow","text":"<p>This example is meant for inspiration. You can structure it in many different ways.</p> .github/workflows/generate-diff.yml<pre><code>name: Diff Preview\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  diff-preview:\n    name: Diff Preview\n    runs-on: your-arc-runner  # Replace with your self-hosted runner label\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: pull-request\n          fetch-depth: 0\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: main\n\n      - uses: azure/setup-kubectl@v4\n        id: install\n\n      # Extract secrets from the host cluster and prepare them for the ephemeral cluster\n      - name: Get secrets from host cluster\n        run: |\n          mkdir -p secrets\n\n          # Get all Argo CD secrets from the host cluster\n          kubectl get secrets -n argocd -o json -l argocd.argoproj.io/secret-type &gt; argocd-secrets.json\n\n          # Clean up cluster-specific metadata that shouldn't be transferred\n          jq '{\n            apiVersion: \"v1\",\n            kind: \"List\",\n            items: [\n              .items[] \n              | del(\n                  .metadata.annotations,\n                  .metadata.creationTimestamp,\n                  .metadata.ownerReferences,\n                  .metadata.resourceVersion,\n                  .metadata.selfLink,\n                  .metadata.uid,\n                  .metadata.managedFields\n                ) \n              | .metadata.namespace = \"argocd\"\n            ]\n          }' argocd-secrets.json &gt; processed-secrets.json\n\n          # Split into individual files\n          counter=1\n          jq -c '.items[]' processed-secrets.json | while IFS= read -r line; do\n            if [ -n \"$line\" ]; then\n              echo \"$line\" | jq '.' &gt; \"secrets/manifest-$(printf \"%03d\" $counter).json\"\n              counter=$((counter + 1))\n            fi\n          done\n\n          # Clean up temporary files\n          rm -f argocd-secrets.json processed-secrets.json\n\n      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/secrets:/secrets \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.19\n\n      - name: Post diff as comment\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre>"},{"location":"getting-started/self-hosted-gh-runner/#approach-2-connecting-to-a-pre-configured-argo-cd","title":"Approach 2: Connecting to a pre-configured Argo CD","text":"<p>For enhanced security and performance, you can skip the ephemeral cluster creation entirely and use a pre-configured Argo CD instance directly. This approach is covered in detail in the Connecting the self-hosted runner to Argo CD on the host cluster guide.</p>"},{"location":"getting-started/self-hosted-gh-runner/#handling-cidr-collisions","title":"Handling CIDR Collisions","text":"<p>When using Action Runner Controller (ARC) to self-host your GitHub Actions runners, the ephemeral kind cluster created by <code>argocd-diff-preview</code> may have CIDR ranges that conflict with your host cluster's network configuration. These overlapping ranges can cause networking issues during the diff preview process.</p>"},{"location":"getting-started/self-hosted-gh-runner/#default-cidr-ranges","title":"Default CIDR Ranges","text":"<p>The kind cluster uses these default CIDR ranges:</p> Type CIDR Range Service 10.96.0.0/16 Pod 10.244.0.0/16 <p>If these ranges overlap with your host cluster's CIDRs, you'll need to configure custom ranges for the ephemeral cluster.</p>"},{"location":"getting-started/self-hosted-gh-runner/#configuring-custom-cidrs","title":"Configuring Custom CIDRs","text":"<p>Step 1: Create a kind configuration file</p> <p>Create a file in your repository (e.g., <code>hack/kind.yaml</code>) with non-overlapping CIDR ranges:</p> hack/kind.yaml<pre><code>kind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnetworking:\n  serviceSubnet: \"10.80.0.0/16\"\n  podSubnet: \"10.128.0.0/16\"\n</code></pre> <p>Step 2: Pass the configuration to <code>argocd-diff-preview</code></p> <p>Add the <code>--kind-options</code> flag to your workflow to use the custom configuration:</p> .github/workflows/generate-diff.yml<pre><code>      - name: Generate Diff\n        run: |\n          docker run \\\n            --network=host \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/main:/base-branch \\\n            -v $(pwd)/pull-request:/target-branch \\\n            -v $(pwd)/output:/output \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.19 \\\n            --kind-options '--config /base-branch/hack/kind.yaml'\n</code></pre>"},{"location":"reusing-clusters/connecting/","title":"Connecting to a cluster with Argo CD pre-installed","text":"<p>Instead of spinning up an ephemeral cluster for each diff preview, you can connect to a cluster with Argo CD already installed. This saves approximately <code>60</code>\u2013<code>90</code> seconds per run.</p> <p>Important: We highly recommend not using your production Argo CD instance for rendering manifests. Instead, install a dedicated Argo CD instance for diff previews.</p> <p>The Argo CD server does not need to be exposed to the internet, since <code>argocd-diff-preview</code> connects via a KubeConfig file (or service account).</p> <p>To use this feature, mount a valid KubeConfig with access to the cluster and provide these options:</p> <pre><code>--create-cluster false --argocd-namespace &lt;namespace&gt;\n</code></pre> <p>This will skip cluster creation and connect to Argo CD via port-forwarding in the specified namespace.</p>"},{"location":"reusing-clusters/connecting/#requirements","title":"Requirements","text":"<ul> <li>The default <code>admin</code> user must not be disabled in Argo CD.</li> <li>The <code>default</code> Argo CD project must exist.</li> <li>The required secrets for authentication have already been added to the cluster.</li> </ul>"},{"location":"reusing-clusters/connecting/#example-demo","title":"Example Demo","text":""},{"location":"reusing-clusters/connecting/#step-1-create-cluster-skip-if-you-already-have-a-cluster-with-argo-cd-installed","title":"Step 1: Create cluster (skip if you already have a cluster with Argo CD installed)","text":"<pre><code>kind create cluster\nhelm repo add argo https://argoproj.github.io/argo-helm\nhelm install argo-cd argo/argo-cd --version 8.0.3 --create-namespace --namespace argocd-diff-preview\n</code></pre> <pre><code># Wait for Argo CD to be ready\nkubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd-diff-preview\n</code></pre>"},{"location":"reusing-clusters/connecting/#step-2-clone-the-base-and-target-branches","title":"Step 2: Clone the base and target branches","text":"<pre><code># Clone the base branch into a subfolder called `base-branch`\ngit clone https://github.com/dag-andersen/argocd-diff-preview base-branch --depth 1 -q \n\n# Clone the target branch into a subfolder called `target-branch`\ngit clone https://github.com/dag-andersen/argocd-diff-preview target-branch --depth 1 -q -b helm-example-3\n</code></pre>"},{"location":"reusing-clusters/connecting/#step-3-run-the-tool","title":"Step 3: Run the tool","text":"<p>Make sure you: - Mount the KubeConfig into the container (<code>-v ~/.kube:/root/.kube</code>) - Disable cluster creation (<code>--create-cluster=false</code>) - Specify the Argo CD namespace (<code>--argocd-namespace=&lt;ns&gt;</code>)</p> <pre><code>docker run \\\n  --network host \\\n  -v ~/.kube:/root/.kube \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -v $(pwd)/output:/output \\\n  -v $(pwd)/base-branch:/base-branch \\\n  -v $(pwd)/target-branch:/target-branch \\\n  -e TARGET_BRANCH=helm-example-3 \\\n  -e REPO=dag-andersen/argocd-diff-preview \\\n  dagandersen/argocd-diff-preview:v0.1.19 \\\n  --argocd-namespace=argocd-diff-preview \\\n  --create-cluster=false\n</code></pre> <p>And then the output will look something like this:</p> <pre><code>\u2728 Running with:\n\u2728 - reusing cluster with Argo CD pre-installed\n\u2728 - base-branch: main\n\u2728 - target-branch: helm-example-3\n\u2728 - output-folder: ./output\n\u2728 - argocd-namespace: argocd-diff-preview\n\u2728 - repo: dag-andersen/argocd-diff-preview\n\u2728 - timeout: 180 seconds\n\ud83d\udd11 Unique ID for this run: 60993\n\ud83e\udd16 Fetching all files for branch (branch: main)\n\ud83e\udd16 Found 52 files in dir base-branch (branch: main)\n...\n\ud83e\udd16 Fetching all files for branch (branch: helm-example-3)\n\ud83e\udd16 Found 52 files in dir target-branch (branch: helm-example-3)\n...\n\ud83e\udd91 Logging in to Argo CD through CLI...\n\ud83e\udd91 Logged in to Argo CD successfully\n\ud83e\udd16 Converting ApplicationSets to Applications in both branches\n...\n\ud83e\udd16 Patching 19 Applications (branch: main)\n\ud83e\udd16 Patching 19 Applications (branch: helm-example-3)\n\ud83e\udd16 Rendered 11 out of 38 applications (timeout in 175 seconds)\n\ud83e\uddfc Waiting for all application deletions to complete...\n\ud83e\uddfc All application deletions completed\n\ud83e\udd16 Got all resources from 19 applications from base-branch and got 19 from target-branch in 7s\n\ud83d\udd2e Generating diff between main and helm-example-3\n\ud83d\ude4f Please check the ./output/diff.md file for differences\n\u2728 Total execution time: 10s\n</code></pre>"},{"location":"reusing-clusters/connecting/#authenticate-with-cloud-providers","title":"Authenticate with Cloud Providers","text":"<p>If you're connecting to a cluster on a cloud provider, you often use a plugin or ExecConfig to authenticate (for example, <code>kubelogin</code> for Azure AKS or <code>aws eks get-token</code> for AWS EKS).</p> <p>You can check this by running <code>kubectl config view --minify -o jsonpath='{.users[*].user}'</code> and looking for the <code>command</code> field.</p> <p>These plugins/binaries are not available inside the Docker image, so you'll need to run <code>argocd-diff-preview</code> as a standalone binary.</p> <p>You can find installation instructions in the docs.</p>"},{"location":"reusing-clusters/self-hosted-gh-runner/","title":"Connecting the self-hosted runner to Argo CD on the host cluster","text":"<p>Running <code>argocd-diff-preview</code> on a self-hosted runner on a cluster that has Argo CD pre-installed combines maximum performance with enhanced security. This approach eliminates both cluster creation overhead and the need to store cluster credentials in your CI/CD pipeline.</p> <p>Instead of creating a temporary cluster for each diff preview, your self-hosted GitHub Actions runner connects directly to a dedicated Argo CD instance running in the same cluster. This offers fast execution (no cluster creation overhead) and enhanced security (no credential sharing).</p> <p>Imagine something like this:</p> <p></p>"},{"location":"reusing-clusters/self-hosted-gh-runner/#how-it-works","title":"How It Works","text":"<ol> <li>Install Action Runner Controller (ARC) in your cluster alongside the dedicated Argo CD instance in the namespace <code>argocd-diff-preview</code></li> <li>The runner uses a service account to connect to the host cluster and access the Argo CD instance</li> <li>The tool runs exactly as before, but without any credential management complexity and without creating an ephemeral cluster</li> </ol>"},{"location":"reusing-clusters/self-hosted-gh-runner/#setup-guide","title":"Setup Guide","text":"<p>This step-by-step guide walks you through setting up self-hosted runners with an existing Argo CD cluster.</p>"},{"location":"reusing-clusters/self-hosted-gh-runner/#step-1-prepare-your-cluster","title":"Step 1: Prepare Your Cluster","text":"<p>If you already have a cluster with Argo CD installed, skip to Step 2. Otherwise, create a dedicated cluster:</p> <pre><code># Create a kind cluster\nkind create cluster --name argocd-diff-preview\n\n# Add Argo CD Helm repository\nhelm repo add argo https://argoproj.github.io/argo-helm\nhelm repo update\n\n# Install Argo CD\nhelm install argo-cd argo/argo-cd \\\n  --version 8.0.3 \\\n  --namespace argocd-diff-preview \\\n  --create-namespace\n</code></pre>"},{"location":"reusing-clusters/self-hosted-gh-runner/#step-2-install-action-runner-controller-arc","title":"Step 2: Install Action Runner Controller (ARC)","text":"<p>ARC Documentation</p> <p>This guide may become outdated. For the latest ARC installation instructions, see the official GitHub documentation.</p> <p>Install the ARC controller and runner scale set to enable self-hosted GitHub Actions runners:</p> <p>Install the controller:</p> <pre><code># Add the ARC Helm repository\nhelm repo add arc-systems https://actions-runner-controller.github.io/arc\nhelm repo update\n\n# Install the controller\nhelm install arc arc-systems/gha-runner-scale-set-controller \\\n  --version 0.12.1 \\\n  --namespace arc-systems \\\n  --create-namespace\n</code></pre> <p>Create authentication secret:</p> <p>First, create a GitHub Personal Access Token (PAT) with <code>repo</code> scope, then create the secret:</p> <pre><code>kubectl create secret generic arc-runner-auth \\\n  --namespace arc-runners \\\n  --from-literal=github_token=\"your-github-token-here\"\n</code></pre> <p>Or using a YAML file:</p> arc-runner-auth.yaml<pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: arc-runner-auth\n  namespace: arc-runners\ntype: Opaque\nstringData:\n  github_token: \"your-github-token-here\"\n</code></pre> <p>Install the runner scale set:</p> <p>Create a configuration file for the runner scale set:</p> arc-runner-set.yaml<pre><code>githubConfigUrl: \"https://github.com/&lt;org&gt;/&lt;repo&gt;\"  # Replace with your repo\ngithubConfigSecret: arc-runner-auth\n\ncontrollerServiceAccount:\n  name: arc-gha-rs-controller\n  namespace: arc-systems\n\nrunnerScaleSetName: argocd-diff-runner  # This name will be used in workflows\n\ntemplate:\n  spec:\n    serviceAccountName: arc-runner\n    automountServiceAccountToken: true\n</code></pre> <p>Install the runner scale set:</p> <pre><code># Add the runner scale set Helm repository\nhelm repo add arc-runners https://actions-runner-controller.github.io/arc\n\n# Install the runner scale set\nhelm install arc-runner-set arc-runners/gha-runner-scale-set \\\n  --version 0.12.1 \\\n  --namespace arc-runners \\\n  --create-namespace \\\n  -f arc-runner-set.yaml\n</code></pre>"},{"location":"reusing-clusters/self-hosted-gh-runner/#step-3-configure-rbac","title":"Step 3: Configure RBAC","text":"<p>The runner service account needs permissions to access Argo CD resources (in the namespace <code>argocd-diff-preview</code>). Create the following RBAC configuration:</p> arc-runner-rbac.yaml<pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: arc-runner\n  namespace: arc-runners\n---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: arc-runner-diff-preview\n  namespace: argocd-diff-preview\nrules:\n  - apiGroups: [\"*\"]\n    resources: [\"*\"]\n    verbs: [\"*\"]\n---\nkind: RoleBinding\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: arc-runner-diff-preview\n  namespace: argocd-diff-preview\nsubjects:\n  - kind: ServiceAccount\n    name: arc-runner\n    namespace: arc-runners\nroleRef:\n  kind: Role\n  name: arc-runner-diff-preview\n  apiGroup: rbac.authorization.k8s.io\n</code></pre> <p>Apply the RBAC configuration:</p> <pre><code>kubectl apply -f arc-runner-rbac.yaml\n</code></pre>"},{"location":"reusing-clusters/self-hosted-gh-runner/#usage","title":"Usage","text":""},{"location":"reusing-clusters/self-hosted-gh-runner/#step-4-create-github-actions-workflow","title":"Step 4: Create GitHub Actions Workflow","text":"<p>Now create a workflow that uses your self-hosted runner. There are two approaches: using the binary directly or using Docker.</p>"},{"location":"reusing-clusters/self-hosted-gh-runner/#option-a-using-the-binary-recommended","title":"Option A: Using the Binary (Recommended)","text":"<p>This approach installs the <code>argocd-diff-preview</code> binary directly on the runner:</p> .github/workflows/diff-preview.yml<pre><code>name: Diff Preview\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  diff-preview:\n    name: Diff Preview\n    runs-on: argocd-diff-runner  # Use your runner scale set name\n    permissions:\n      contents: read\n      pull-requests: write\n\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          path: target-branch\n          fetch-depth: 0\n\n      - uses: actions/checkout@v4\n        with:\n          ref: main\n          path: base-branch\n\n      - name: Setup kubectl\n        uses: azure/setup-kubectl@v4\n\n      - name: Install Argo CD CLI\n        run: |\n          curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64\n          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd\n          rm argocd-linux-amd64\n          argocd version\n\n      - name: Install argocd-diff-preview\n        run: |\n          curl -LJO https://github.com/dag-andersen/argocd-diff-preview/releases/download/v0.1.17/argocd-diff-preview-Linux-x86_64.tar.gz\n          tar -xvf argocd-diff-preview-Linux-x86_64.tar.gz\n          sudo mv argocd-diff-preview /usr/local/bin\n          argocd-diff-preview --version\n\n      - name: Generate Diff\n        run: |\n          argocd-diff-preview \\\n            --repo ${{ github.repository }} \\\n            --base-branch main \\\n            --target-branch refs/pull/${{ github.event.number }}/merge \\\n            --argocd-namespace=argocd-diff-preview \\\n            --create-cluster=false\n\n      - name: Comment preview\n        run: |\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md --edit-last || \\\n          gh pr comment ${{ github.event.number }} --repo ${{ github.repository }} --body-file output/diff.md\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Key configuration points:</p> <ul> <li><code>runs-on: argocd-diff-runner</code> - Must match your <code>runnerScaleSetName</code> from Step 2</li> <li><code>--argocd-namespace=argocd-diff-preview</code> - Change if your Argo CD uses a different namespace</li> <li><code>--create-cluster=false</code> - Critical flag that tells the tool to use a pre-provisioned cluster</li> </ul>"},{"location":"reusing-clusters/self-hosted-gh-runner/#option-b-using-docker","title":"Option B: Using Docker","text":"<p>If you prefer to use the Docker image (requires Docker installed on runner pods):</p> .github/workflows/diff-preview-docker.yml<pre><code>      - name: Generate Diff\n        run: |\n          docker run \\\n            --network host \\\n            -v ~/.kube:/root/.kube \\\n            -v /var/run/docker.sock:/var/run/docker.sock \\\n            -v $(pwd)/output:/output \\\n            -v $(pwd)/base-branch:/base-branch \\\n            -v $(pwd)/target-branch:/target-branch \\\n            -e TARGET_BRANCH=refs/pull/${{ github.event.number }}/merge \\\n            -e REPO=${{ github.repository }} \\\n            dagandersen/argocd-diff-preview:v0.1.19 \\\n            --argocd-namespace=argocd-diff-preview \\\n            --create-cluster=false\n</code></pre> <p>Important Docker considerations:</p> <ul> <li><code>--network host</code> - Allows the container to access the cluster using the runner's network</li> <li><code>-v ~/.kube:/root/.kube</code> - Mounts kubeconfig for cluster access</li> <li><code>-v /var/run/docker.sock:/var/run/docker.sock</code> - Required if using Docker-in-Docker features</li> <li>Docker must be installed and accessible on the runner pods</li> </ul>"},{"location":"reusing-clusters/self-hosted-gh-runner/#expected-output","title":"Expected Output","text":"<p>When the workflow runs successfully, you'll see output similar to this in your GitHub Actions logs:</p> <pre><code>\u2728 Running with:\n\u2728 - reusing cluster with Argo CD pre-installed\n\u2728 - base-branch: main\n\u2728 - target-branch: refs/pull/123/merge\n\u2728 - output-folder: ./output\n\u2728 - argocd-namespace: argocd-diff-runner\n\u2728 - repo: your-org/your-repo\n\u2728 - timeout: 180 seconds\n\ud83d\udd11 Unique ID for this run: 60993\n\ud83e\udd16 Fetching all files for branch (branch: main)\n\ud83e\udd16 Found 52 files in dir base-branch (branch: main)\n...\n\ud83e\udd91 Logging in to Argo CD through CLI...\n\ud83e\udd91 Logged in to Argo CD successfully\n\ud83e\udd16 Converting ApplicationSets to Applications in both branches\n...\n\ud83e\udd16 Patching 19 Applications (branch: main)\n\ud83e\udd16 Patching 19 Applications (branch: refs/pull/123/merge)\n\ud83e\udd16 Rendered 11 out of 38 applications (timeout in 175 seconds)\n\ud83e\uddfc Waiting for all application deletions to complete...\n\ud83e\uddfc All application deletions completed\n\ud83e\udd16 Got all resources from 19 applications from base-branch and got 19 from target-branch in 7s\n\ud83d\udd2e Generating diff between main and refs/pull/123/merge\n\ud83d\ude4f Please check the ./output/diff.md file for differences\n\u2728 Total execution time: 10s\n</code></pre>"}]}