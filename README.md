> This repository is work in progress. The tool is not yet ready for use yet.

# Argo CD Diff Preview

![](./images/example.png)

Argo CD Diff Preview is a tool that renders the diff between two branches in a Git repository. It is designed to render manifests generated by Argo CD, providing a clear and concise view of the changes between two branches. It operates similarly to Atlantis for Terraform, creating a plan that outlines the proposed changes.

### 3 Example pull requests:
- [Helm Example | Internal Chart](https://github.com/dag-andersen/argocd-diff-preview/pull/3)
- [Helm example | External Chart: Nginx](https://github.com/dag-andersen/argocd-diff-preview/pull/2)
- [Kustomize Example](https://github.com/dag-andersen/argocd-diff-preview/pull/1)

## Why do we need this?

In the Kubernetes world, we often use templating tools like Kustomize and Helm to generate our Kubernetes manifests. These tools make maintaining and streamlining configuration easier across applications and environments. However, they also make it harder to visualize the application's actual configuration in the cluster.

Mentally parsing Helm templates and kustomize patches is very hard without rendering the output. Thus, It is quite easy to make mistakes while modifying an application's configuration.

In the field of GitOps and infrastructure as code, all configuration is checked into git, and modified through PRs. The code changes in the PR are reviewed by a human, and the human needs to understand the changes made to the configuration. This is hard when the configuration is generated through templating.

## Overview

The safest way to render your Helm Charts and Kustomize Overlays is to let ArgoCD render them for you. This can be done by spinning up an ephemeral cluster inside testing pipeline. 

The implementation is actually quite simple. It just follows the steps below:

#### 10 steps
1. Start a local cluster
2. Install ArgoCD
3. Add the required credentials (git credentials, image pull secrets, etc.)
4. Fetch all ArgoCD application files on your PR branch
   - Point their `targetRevision` to the Pull Request branch.
   - Remove the `syncPolicy` from the application (to avoid the application to sync locally)
1. Apply the modified applications to the cluster
2. Let ArgoCD do its magic
3. Extract the rendered manifests from the ArgoCD server.
4. Repeat steps 4â€“7 for the base branch (main branch)
5. Create a diff between the manifests rendered from each branch.
6. Display the diff in the PR

## Features

- Renders manifests generated by Argo CD
- Spins up a fully ephemeral cluster. No need to have access to the cluster where the applications are deployed.
- Can run on your local machine as well, before you open the PR.
- Provides a clear and concise view of the changes
- Render resource from external sources (e.g. Helm charts). For example when you update chart version of nginx then you can get a render of the new output. This is useful, to spot if e.g., default values change.- Example [PR]([link](https://github.com/dag-andersen/argocd-diff-preview/pull/2)). 

### Not supported
- Does not support ArgoCD CMP plugins
- Does not work Cluster Generators in your ApplicationSets

## Installation and Usage

### Run as container image

```bash
docker run \
   -v /var/run/docker.sock:/var/run/docker.sock \     # This is needed to access the host's docker daemon.
   --network host \                                   # This is needed so the container can access the local cluster on the host's docker daemon.
   -v <path-to-main-branch>:/base-branch \            # This is the main branch's ArgoCD applications.
   -v <path-to-pr-branch>:/target-branch \
   -v $(pwd)/output:/output \
   -e base_branch=main \
   -e target_branch=<name-of-the-target-branch> \
   dag-andersen/argocd-diff
```

<details>
  <summary>Example in GitHub Actions workflow</summary>

```yaml
- uses: actions/checkout@v4
  with:
    path: pull-request

- uses: actions/checkout@v4
  with:
    ref: main
    path: main

- name: Diff
  run: |
    docker run \
      --network=host \
      -v /var/run/docker.sock:/var/run/docker.sock \
      -v $(pwd)/main:/base-branch \
      -v $(pwd)/pull-request:/target-branch\
      -v $(pwd)/output:/output \
      -e RUST_LOG=info \
      -e TARGET_BRANCH=${{ github.head_ref }} \
      -e GIT_REPO="https://github.com/dag-andersen/argocd-diff-preview.git" \
      dagandersen/argocd-diff-preview:latest-amd64
    cat output/diff.md

- name: post comment 
  run: |
    gh pr comment ${{ github.event.number }} --edit-last --body-file output/diff.md \
      || gh pr comment ${{ github.event.number }} --body-file output/diff.md
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

</details>


### Run as binary (WORK IN PROGRESS)

<!--

*Pre-requisite:*
- Install [gh](https://cli.github.com/manual/installation) CLI
- Install [kind](https://kind.sigs.k8s.io/docs/user/quick-start/) CLI
- Install [argocd](https://argoproj.github.io/argo-cd/cli_installation/) CLI

```bash
gh release download v0.1.0
chmod +x argocd-diff
./argocd-diff --base-branch main --target-branch feature-branch
```

<details>
  <summary>Example in GitHub Actions workflow</summary>
  
```yaml
name: Render ArgoCD Diff

on:
  pull_request:
    branches:
      - main

jobs:
  argocd-diff-preview:
    runs-on: ubuntu
    permissions: write-all # TODO: pick a less permissive permission

    steps:
      - uses: actions/checkout@v4
         with:
            path: pull-reques

      - uses: actions/checkout@v4
         with:
            ref: main
            path: main

      - name: Diff
         run: |
            gh release download v0.1.0 --repo dag-andersen/argocd-diff
            chmod +x argocd-diff
            ./argocd-diff --base-branch main --target-branch feature-branch

      - name: Comment Diff
         run: |
            gh pr comment ${{ github.event.number }} --body-file output/message.md
```

</details>

-->

### Handling credentials

In the simple example above, I do not provide the cluster with any credentials, which only works if the image registry and the git repository are public. If you want to use this in a private repository, you need to provide the cluster with the required credentials.

Since your Git repository might not be public (like in my example above) you need to provide the tool with the necessary read-access credentials for the repository. This can be done by placing the ArgoCD secrets in folder mounted at `/secrets`. When the tool starts, it will simply run `kubectl apply -f /secrets` to apply every resource to the cluster, before starting the rendering process.

<details>
  <summary>Example - Username + Password </summary>

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: argoproj-https-creds
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repo-creds
stringData:
  url: https://github.com/argoproj
  type: helm
  password: my-password
  username: my-username
```
</details>

<details>
  <summary>Example - GitHub App </summary>

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: github-creds
  namespace: argocd
  labels:
    argocd.argoproj.io/secret-type: repo-creds
stringData:
  url: https://github.com/argoproj
  type: helm
  githubAppID: 1
  githubAppInstallationID: 2
  githubAppPrivateKey: |
    -----BEGIN OPENSSH PRIVATE KEY-----
    ...
    -----END OPENSSH PRIVATE KEY-----
```
</details>

For more info, see the [Argo CD docs](https://argo-cd.readthedocs.io/en/stable/operator-manual/argocd-repo-creds-yaml/)

### Scalability and performance
Rendering the manifests of every single application on each PR can be slow slow. This can be annoying, especially if only a few applications have changed. The tool supports grepping applications with regex. Setting the environment variable `FILE_NAME_REGEX` means the tool only runs on manifests that that matches the regex.

E.g., If there is only changes in applications stored under `/team-a/*`, then you can run the tool with `FILE_NAME_REGEX=*/Team-A/*` to only render applications in that folder. This speeds up the process significantly.

### Options
```
USAGE:
    argocd-diff-preview [FLAGS] [OPTIONS] --git-repo <git-repository> --target-branch <target-branch>

FLAGS:
    -d, --debug      Activate debug mode
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -b, --base-branch <base-branch>          [env: BASE_BRANCH=]  [default: main]
    -i, --diff-ignore <diff-ignore>          [env: DIFF_IGNORE=]
    -r, --file-regex <file-regex>           Where to write the output: to `stdout` or `file` [env: FILE_REGEX=]
    -g, --git-repo <git-repository>          [env: GIT_REPO=]
    -o, --output-folder <output-folder>      [env: OUTPUT_FOLDER=]  [default: ./output]
    -s, --secret-folder <secrets-folder>     [env: SECRET_FOLDER=]  [default: ./secrets]
    -t, --target-branch <target-branch>      [env: TARGET_BRANCH=]
        --timeout <timeout>                 Set timeout [env: TIMEOUT=]  [default: 180]
```

### Roadmap
- Make a dedicated GitHub Action that wraps the Docker container in a more user-friendly way. 
- Let the user specify Argo CD version. Currently it always uses the newest version available.
- Support `git config --get remote.origin.url` to get the repo URL automatically.
- Delete applications, when they have been parsed, so Argo CD can focus on the remaining applications, which hopefully speeds up the process. 

### Do you experience any issues?

If you experience any issues, please open an issue in this repository. We will do our best to address it as soon as possible. I only have limited codebases available to me, so I can't test it on all possible codebases. 

### Questions, issues, or suggestions

If you have any questions, issues, or suggestions, please open an issue in this repository.
Any contributions are **greatly appreciated**. 
