# Argo CD: Previewing Pull Requests changes in SECONDS! ü•µ‚ö°Ô∏è‚è∞

> **TL;DR**: You can now render previews of your PRs by using a cluster with Argo CD pre-installed instead of spinning up a new one each run. This results in very short preview times while maintaining accuracy. 

This is a continuation of my first blog post: [Rendering the TRUE Argo CD diff on your PRs](https://dev.to/dag-andersen/rendering-the-true-argo-cd-diff-on-your-prs-10bk). That article addresses a critical challenge in GitOps workflows: visualizing the actual impact of configuration changes when using templating tools like Helm and Kustomize.

The article shows how you can render changes to your manifests/Argo CD configuration directly on your pull requests.

In short, it shows how you can transform a pull request like this:

!["PR code changes"](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5uj1woylw7979u1s50t9.png)

and turn it into a preview like this: 
 
!["Preview of the diff"](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/x2ia44gwlsogt1s5vgjn.png) 

Here are some examples:

**3 Example Pull Requests:**
- [Helm Example | Internal Chart](https://github.com/dag-andersen/argocd-diff-preview/pull/16)
- [Helm example | External Chart: Nginx](https://github.com/dag-andersen/argocd-diff-preview/pull/15)
- [Kustomize Example](https://github.com/dag-andersen/argocd-diff-preview/pull/12)

---

## Three Approaches to Preview Generation

Since its introduction in 2024, the tool now supports more ways of running it, so you can optimize it for your use case! All three approaches are perfectly valid and you can choose the one that best fits your needs.

### Approach 1: Ephemeral Clusters (Original)

This is the simplest solution, but also the slowest...

The original solution spins up ephemeral Kubernetes clusters inside your CI/CD pipeline, letting Argo CD itself render the manifests. This ensures maximum accuracy since the same engine that will deploy your changes generates the preview.

!["Ephemeral cluster approach"](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fg16gqjm0488hxl4x8ov.png)

**How it works:**
1. Create an ephemeral Kubernetes cluster (kind, k3d, or minikube)
2. Install Argo CD from scratch
3. Apply your applications (without syncing them)
4. Wait for Argo CD to render the Applications in memory
5. Extract the manifests from the cluster
6. Generate the diff between the two sets of rendered manifests
7. Post the diff to the pull request

This is the approach described in detail in the [first blog post](https://dev.to/dag-andersen/rendering-the-true-argo-cd-diff-on-your-prs-10bk).

**Why this approach is superior to alternative tools:**
- **True accuracy**: Uses Argo CD itself rather than tools that try to mimic its rendering logic
- **No infrastructure access required**: Can work without credentials for your production Argo CD instance
- **Complete isolation**: Can run in complete isolation from your production systems

However, this approach has one significant limitation: **Speed**. Creating a cluster and installing Argo CD takes ~60 seconds every time, making even simple configuration changes take 80+ seconds to preview.

This leads us to the next approach to running `argocd-diff-preview`.

**Trade-offs:**
- ‚úÖ Zero setup
- ‚úÖ Complete isolation
- ‚úÖ Works with any CI/CD (even works on your local machine)
- ‚ùå Slow (~60 second overhead per run)
- ‚ùå Resource-intensive (creates a new cluster for each run)

---

### Approach 2: Cluster with Argo CD pre-installed

Instead of creating a new ephemeral cluster each time, `argocd-diff-preview` can now connect to a cluster with Argo CD already installed. This reduces preview times from minutes to seconds! ü§Ø

See it as a cluster with Argo CD pre-installed that is on standby and ready to render your manifests. Remember, the cluster only runs Argo CD and not the resources generated by the Applications. So it is fairly lightweight.

We do not recommend using your _normal_ Argo CD instance for this. Instead, create a dedicated cluster or Argo CD instance for diff previews.

!["Cluster with Argo CD pre-installed approach"](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zhyupnhw2ese3iz8mmcb.png)

**How it works:**
1. Connect to the cluster
2. Apply your applications (without syncing them)
3. Wait for Argo CD to render the Applications in memory.
4. Extract the manifests from the cluster
5. Generate the diff between the two sets of rendered manifests
6. Post the diff to the pull request

**Quick Demo:**
```bash
# Create cluster and install Argo CD (one-time setup)
kind create cluster
helm repo add argo https://argoproj.github.io/argo-helm
helm install argo-cd argo/argo-cd --version 8.0.3 --create-namespace --namespace argocd-diff-preview

# Wait for Argo CD to be ready
kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd-diff-preview

# Clone each branch from the PR into subfolders
git clone https://github.com/dag-andersen/argocd-diff-preview base-branch --depth 1 -q 
git clone https://github.com/dag-andersen/argocd-diff-preview target-branch --depth 1 -q -b helm-example-3

# Run the tool (connects to the kind cluster)
docker run \
  --network host \
  -v ~/.kube:/root/.kube \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v $(pwd)/output:/output \
  -v $(pwd)/base-branch:/base-branch \
  -v $(pwd)/target-branch:/target-branch \
  -e TARGET_BRANCH=helm-example-3 \
  -e REPO=dag-andersen/argocd-diff-preview \
  dagandersen/argocd-diff-preview:v0.1.18 \
  --argocd-namespace=argocd-diff-preview \
  --create-cluster=false
```

**Concurrent Runs: Multiple PRs, No Conflicts**

Each run uses a unique identifier, so multiple PRs can run without collisions.

**Network & Security:**

The main downside here is that you need access to the Kubernetes API from your GitHub/GitLab hosted pipeline. Some organizations will see this as a no-go... which leads us to the next way of running `argocd-diff-preview`... 

**Trade-offs:**
- ‚úÖ Fast execution (eliminates ~60s overhead)
- ‚úÖ Utilizes Argo CD caching from previous runs
- ‚ùå Infrastructure setup required (set up a cluster with Argo CD beforehand) 
- ‚ùå Cluster credentials in CI/CD pipeline

---

### Approach 3: Cluster with Argo CD pre-installed + Self-Hosted Runner

Running `argocd-diff-preview` on a self-hosted runner inside a cluster that has Argo CD pre-installed combines maximum performance with enhanced security. This approach eliminates both cluster creation overhead and the need to store cluster credentials in your CI/CD pipeline.

Instead of creating a temporary cluster for each diff preview, your self-hosted GitHub Actions runner connects directly to a dedicated Argo CD instance running in the same cluster as the hosted runners. This offers fast execution (no cluster creation overhead) and enhanced network and credential security.

!["Cluster with Argo CD pre-installed + self-hosted runner approach"](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6nomrkuvrogliedld30d.png)

**Setup Guide:**

1. **Install Action Runner Controller (ARC)** in your cluster alongside the dedicated Argo CD instance in the namespace `argocd-diff-preview`
2. **The runner uses a service account** to connect to the host cluster and access the Argo CD instance
3. **The tool runs exactly as before**, but without any credential management complexity and without creating an ephemeral cluster

> **Note**: This setup is more complex than the previous two approaches. For complete setup instructions, see the [self-hosted runner guide](https://dag-andersen.github.io/argocd-diff-preview/reusing-clusters/self-hosted-gh-runner/).

**Trade-offs:**
- ‚úÖ Fast execution (eliminates ~60s overhead)
- ‚úÖ Network isolation (No need to expose your cluster to the internet)
- ‚úÖ No cluster credentials in CI/CD pipeline because you are using a service account from within the cluster and Argo CD already has all the credentials it needs
- ‚ùå Most complex setup (requires self-hosted runners + dedicated Argo CD)

---

## Optimizing for Large Repositories

Even when using a cluster with Argo CD pre-installed, repositories with hundreds of applications can take 1+ minutes to render. The solution is selective rendering using annotations.

The most powerful optimization is the `argocd-diff-preview/watch-pattern` annotation. This tells the tool exactly which files each application cares about. An application will only be rendered if its watch patterns match any of the changed files in the PR.

### Smart Application Selection

**Setup Guide:**
1. Add the `argocd-diff-preview/watch-pattern` annotation to your Applications and ApplicationSets
2. Enable automatic file change detection. Use the following flags:
   1. `--auto-detect-files-changed=true` 
   2. `--watch-if-no-watch-pattern-found=true`


**Example:**

Use the `argocd-diff-preview/watch-pattern` annotation to tell the tool exactly which files each application cares about:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: my-app
  namespace: argocd
  annotations:
    argocd-diff-preview/watch-pattern: "apps/my-app/.*, shared/values.yaml"
spec:
  source:
    path: apps/my-app
    # ...
```

This application will only render if:
- Any file in the `apps/my-app/` directory changes
- The `shared/values.yaml` file changes
- The application's own manifest file changes (automatic)

More information about the `watch-pattern` annotation can be found in the [application-selection](https://dag-andersen.github.io/argocd-diff-preview/application-selection/) documentation.

**Other application selection methods:**
- **Ignore applications**: `argocd-diff-preview/ignore: "true"`
- **Filter by labels**: `--selector "team=frontend"`
- **Filter by path**: `--file-regex="/team-a/"`

**Performance impact**: Instead of rendering 100+ applications (60+ seconds), render only 6-10 relevant applications (~10 seconds).

For complete details, see the [application-selection documentation](https://dag-andersen.github.io/argocd-diff-preview/application-selection/).

---

## Comparison: Which Approach to Choose?

| Approach                                                    | Best For                              | Pros                                                                        | Cons                                                                                                               |
| ----------------------------------------------------------- | ------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| **Ephemeral clusters**                                      | Getting started, Full isolation       | ‚Ä¢ Simple setup<br>‚Ä¢ Complete isolation                                      | ‚Ä¢ Slow (~60s overhead)                                                                                             |
| **Cluster with Argo CD pre-installed**                      | Teams prioritizing speed              | ‚Ä¢ Fast <br>‚Ä¢ Leverages Argo CD caching                                      | ‚Ä¢ Requires dedicated Argo CD setup<br>‚Ä¢ Need cluster credentials in CI/CD<br>‚Ä¢ Infrastructure maintenance          |
| **Cluster with Argo CD pre-installed + self-hosted runner** | Teams prioritizing speed AND security | ‚Ä¢ Fast + secure<br>‚Ä¢ Leverages Argo CD caching<br>‚Ä¢ No credentials in CI/CD | ‚Ä¢ Most complex setup<br> ‚Ä¢ Requires dedicated Argo CD and self-hosted runner setup<br>‚Ä¢ Infrastructure maintenance |

## Real-World Results

At [Egmont](https://www.egmont.com), we use the "_Cluster with Argo CD pre-installed + self-hosted runner_" approach with a repository containing 600+ applications. Combined with smart application selection, we achieve preview times under 10 seconds - a 20x improvement over the original "_ephemeral cluster_" approach.

Each pull request preview includes a `stats` section at the bottom.

![stats section in preview](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/m4hn4g2pmykx4bmu5vda.png)

The key is combining two optimizations:
1. **Use a cluster with Argo CD pre-installed** to eliminate cluster creation overhead
2. **Select only affected applications** using watch patterns to minimize rendering scope

This approach maintains the accuracy that makes `argocd-diff-preview` superior to alternatives while delivering the preview in seconds.

---

## Conclusion

The evolution of `argocd-diff-preview` proves you don't have to choose between accuracy and speed. What started as an accurate - but slow - solution has matured into a flexible tool that adapts to your team's needs - whether you prioritize simplicity, speed, or security.

Throughout this journey, one principle has remained constant: **use Argo CD itself to render manifests**. This ensures your previews perfectly match what will actually deploy. What's new is the speed at which this happens. By using a cluster with Argo CD pre-installed and intelligently selecting applications, we've compressed preview times from minutes to seconds - making the feedback loop fast enough for practical daily use.

I suggest that you begin with the "_ephemeral cluster_" approach to get familiar with the tool. As your confidence grows and speed becomes a priority, you can consider if you should switch to a faster setup using a cluster with Argo CD pre-installed. Combine this with well-placed `argocd-diff-preview/watch-pattern` annotations and you can achieve preview times under 10 seconds while maintaining the same accuracy you started with, even at scale.

The result? Preview times under 10 seconds with the same accuracy you started with üéâ

---

For detailed setup instructions, check out:
- [Connecting to an already running cluster](https://dag-andersen.github.io/argocd-diff-preview/reusing-clusters/connecting/)
- [Self-Hosted GitHub Actions Runners on Kubernetes](https://dag-andersen.github.io/argocd-diff-preview/getting-started/self-hosted-gh-runner/)
- [Application Selection](https://dag-andersen.github.io/argocd-diff-preview/application-selection/)